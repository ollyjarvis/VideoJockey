import type { Fn } from './types';
type UnsubscribeFn = Fn<[], void>;
/**
 * A workaround for the limitation from Typescript
 * @see {@link https://github.com/microsoft/TypeScript/issues/32164}
 * with the Assumption that there is only 1 overload, we pick the overload
 * instead of the last one, and fallaback to the original implementation if
 * there is no overload.
 */
type Params<E extends (...args: any) => any> = E extends {
    (type: infer T, callback: infer C, options: infer O): void;
    (...args: any): void;
} ? [T, C, O] : Parameters<E>;
/**
 * Subscribe an EventTarget's event and return a unsubscribe function
 *
 * @param target - An EventTarget to be subscribed
 * @param type - The type to pass into `addEventListener` function
 * @param handler - The handle to pass into `addEventListener` function
 * @param options - The options to pass into `addEventListener` function
 */
export declare const subscribeEvent: <T extends EventTarget>(target: T, type: Params<T["addEventListener"]>[0], handler: Params<T["addEventListener"]>[1], options?: Params<T["addEventListener"]>[2] | undefined) => UnsubscribeFn;
export {};
