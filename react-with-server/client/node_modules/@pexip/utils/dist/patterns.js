import { pipe } from './pipe';
/*******************************************************************************
 * Constants
 ******************************************************************************/
// ## Escaped Literals
export const ASTERISK = '\\*';
export const BACKSLASH = '\\\\';
export const CARET = '\\^';
export const CLOSE_BRACE = '\\}';
export const CLOSE_BRACKET = '\\]';
export const CLOSE_PARENTHESE = '\\)';
export const DOLLAR = '\\$';
export const DOT = '\\.';
export const OPEN_BRACE = '\\{';
export const OPEN_BRACKET = '\\[';
export const OPEN_PARENTHESE = '\\(';
export const PIPE = '\\|';
export const PLUS = '\\+';
export const QUESTION_MARK = '\\?';
/**
 * ## Numeric Identifier
 * A single `0`, or a non-zero digit followed by zero or more digits.
 */
export const NUMERIC = '0|[1-9]\\d*';
/**
 * ## Numeric Lose Identifier
 * At least 1 digit.
 */
export const NUMERICLOSE = '[0-9]+';
/**
 * ## Non-numeric Identifier
 * Zero or more digits, followed by a letter or hyphen, and then zero or
 * more letters, digits, or hyphens.
 */
export const NONNUMERIC = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
/*
 * ## Build Metadata Identifier
 * Any combination of digits, letters, or hyphens.
 */
export const BUILD = '[0-9a-zA-Z-]+';
/*******************************************************************************
 * Helpers
 ******************************************************************************/
/**
 * Capture everything enclosed, i.e. `(...)`
 */
const toCapturingGroup = (pattern) => `(${pattern})`;
/**
 * Named Capturing group, i.e. `(?<name>...)`
 */
const toNamedCapturingGroup = (name, pattern) => toCapturingGroup(`?<${name}>${pattern}`);
/**
 * Non-Capturing group, i.e. `(?:...)`
 */
const toNonCapturingGroup = (pattern) => toCapturingGroup(`?:${pattern}`);
/**
 * Zero or one, i.e. `a?`
 */
const toOptional = (pattern) => `${toNonCapturingGroup(pattern)}?`;
/**
 * Zero or more, i.e. `a*`
 */
const toAny = (pattern) => `${toNonCapturingGroup(pattern)}*`;
/**
 * Any number from min to max
 *
 * @param pattern - The pattern to quantify
 * @param min - Minimum number of the pattern
 * @param max - Maximum number of the pattern, can be `undefined` means unlimited
 *
 * @example
 * - min: 3 & max: `undefined`, 3 or more of a. i.e. `a{3,}`
 * - min: 3 & max: 3, exactly 3 of a. i.e. `a{3,3}`
 * - min: 3 & max: 6, Between 3 and 6 of a. i.e. `a{3,6}`
 */
const toMinMax = (pattern, min, max) => `${toNonCapturingGroup(pattern)}{${min},${max ?? ''}}`;
/**
 * Match either from provided patterns, i.e. `a|b`
 */
const toAlt = (...patterns) => patterns.map(pattern => toNonCapturingGroup(pattern)).join('|');
/**
 * Match from the start of the pattern, i.e. `^a`
 */
const toBegin = (pattern) => `^${pattern}`;
/**
 * Match to the end of the pattern, i.e. `a$`
 */
const toEnd = (pattern) => `${pattern}$`;
const isCombinator = (t) => {
    if (typeof t === 'function') {
        return true;
    }
    return false;
};
const resolvePatternOrCombinator = (combine) => (patternOrCombinator) => isCombinator(patternOrCombinator)
    ? patternOrCombinator(combine)
    : patternOrCombinator;
const combineIndentity = (name, valueType) => (combine) => pattern => {
    combine(name, valueType);
    return pattern;
};
const doNothing = () => pattern => pattern;
const createCombinator = (map, ic = doNothing) => (patternOrCombinator) => (combine) => pipe(resolvePatternOrCombinator(combine), ic(combine), map)(patternOrCombinator);
/*******************************************************************************
 * Combinators
 ******************************************************************************/
/**
 * A Combinator to group pattern. When `name` is provided, it will be one of the
 * keys that returned from @see {@link Parser}. This will be the main function
 * to extract information for parsing
 * @param patternOrCombinator - The pattern to group
 * @param name - The name for the capturing. when no provided, there is no
 * capturing
 * @param valueType - The type that the capture should be. @see {@link ValueType}
 * @defaultValue 'string'
 */
export const group = (patternOrCombinator, name, valueType) => createCombinator(pattern => name
    ? toNamedCapturingGroup(name, pattern)
    : toNonCapturingGroup(pattern), combineIndentity(name, valueType))(patternOrCombinator);
/**
 * A Combinator to make the provided pattern's occurrence as optional. i.e. `?`
 * @param patternOrCombinator - The pattern to apply
 */
export const option = createCombinator(pattern => toOptional(pattern));
/**
 * A Combinator to make the provided pattern's occurrence as any or more, i.e. `*`
 * @param patternOrCombinator - The pattern to apply
 */
export const any = createCombinator(pattern => toAny(pattern));
/**
 * A Combinator to make the provided pattern's occurrence as in specified range.
 * i.e. `{min,max}`
 * @param patternOrCombinator - The pattern to apply
 * @param min - The minimum occurrence
 * @param max - The Maximum occurrence, `undefined` means unlimited
 */
export const range = (patternOrCombinator, min, max) => createCombinator(pattern => toMinMax(pattern, min, max))(patternOrCombinator);
/**
 * A Combinator to make the provided patterns as a combination of alternatives
 * @param patternOrCombinators - The combination of alternatives, e.g. `a|b|c`
 */
export const alt = (...patternOrCombinators) => combine => {
    const resolve = resolvePatternOrCombinator(combine);
    const patterns = patternOrCombinators.map(resolve);
    return toAlt(...patterns);
};
/**
 * A Combinator to join the provided patterns as a single pattern
 * @param patternOrCombinators - The patterns to join.
 */
export const join = (...patternOrCombinators) => combine => {
    const resolve = resolvePatternOrCombinator(combine);
    return patternOrCombinators.map(resolve).join('');
};
/**
 * A Combinator for the match start of a string.
 * @param patternOrCombinators - The patterns to be applied.
 */
export const begin = createCombinator(pattern => toBegin(pattern));
/**
 * A Combinator for the match end of a string.
 * @param patternOrCombinators - The patterns to be applied.
 */
export const end = createCombinator(pattern => toEnd(pattern));
const numeric = /^[0-9]+$/;
export const createTokenizer = () => {
    const patterns = [];
    const valueMap = new Map();
    const updateValueMap = (name, valueType = 'string') => {
        if (name) {
            valueMap.set(name, valueType);
        }
    };
    const toPattern = (patternOrCombinator) => isCombinator(patternOrCombinator)
        ? patternOrCombinator(updateValueMap)
        : patternOrCombinator;
    const tokenizer = {
        push: (patternOrCombinator) => {
            const pattern = toPattern(patternOrCombinator);
            patterns.push(pattern);
            return tokenizer;
        },
        between: (start, end) => {
            if (start) {
                const pattern = toPattern(start);
                patterns.unshift(pattern);
            }
            if (end) {
                const pattern = toPattern(end);
                patterns.push(pattern);
            }
            return tokenizer;
        },
        build: () => {
            const pattern = patterns.join('');
            const regex = new RegExp(pattern);
            return {
                print: () => pattern,
                parse: (str) => {
                    const matched = str.trim().match(regex);
                    if (!matched) {
                        return null;
                    }
                    const groups = matched.groups
                        ? Object.entries(matched.groups).reduce((accm, [key, value]) => {
                            // Convert to number
                            if (valueMap.get(key) === 'number') {
                                const num = +value;
                                if (!Number.isFinite(num)) {
                                    return accm;
                                }
                                return { ...accm, [key]: +value };
                            }
                            return value ? { ...accm, [key]: value } : accm;
                        }, {})
                        : undefined;
                    const matchedArray = matched.flatMap((value, index) => index ? [numeric.test(value) ? +value : value] : []);
                    return { list: matchedArray, groups };
                },
            };
        },
    };
    return tokenizer;
};
