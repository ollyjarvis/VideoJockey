/*******************************************************************************
 * Constants
 ******************************************************************************/
export declare const ASTERISK = "\\*";
export declare const BACKSLASH = "\\\\";
export declare const CARET = "\\^";
export declare const CLOSE_BRACE = "\\}";
export declare const CLOSE_BRACKET = "\\]";
export declare const CLOSE_PARENTHESE = "\\)";
export declare const DOLLAR = "\\$";
export declare const DOT = "\\.";
export declare const OPEN_BRACE = "\\{";
export declare const OPEN_BRACKET = "\\[";
export declare const OPEN_PARENTHESE = "\\(";
export declare const PIPE = "\\|";
export declare const PLUS = "\\+";
export declare const QUESTION_MARK = "\\?";
/**
 * ## Numeric Identifier
 * A single `0`, or a non-zero digit followed by zero or more digits.
 */
export declare const NUMERIC = "0|[1-9]\\d*";
/**
 * ## Numeric Lose Identifier
 * At least 1 digit.
 */
export declare const NUMERICLOSE = "[0-9]+";
/**
 * ## Non-numeric Identifier
 * Zero or more digits, followed by a letter or hyphen, and then zero or
 * more letters, digits, or hyphens.
 */
export declare const NONNUMERIC = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
export declare const BUILD = "[0-9a-zA-Z-]+";
type PatternString = string;
type ValueType = 'string' | 'number';
type Combine = (key?: string, valueType?: ValueType) => void;
type Combinator = (combine: Combine) => PatternString;
type PatternCombinator = PatternString | Combinator;
/*******************************************************************************
 * Combinators
 ******************************************************************************/
/**
 * A Combinator to group pattern. When `name` is provided, it will be one of the
 * keys that returned from @see {@link Parser}. This will be the main function
 * to extract information for parsing
 * @param patternOrCombinator - The pattern to group
 * @param name - The name for the capturing. when no provided, there is no
 * capturing
 * @param valueType - The type that the capture should be. @see {@link ValueType}
 * @defaultValue 'string'
 */
export declare const group: (patternOrCombinator: PatternCombinator, name?: string, valueType?: ValueType) => Combinator;
/**
 * A Combinator to make the provided pattern's occurrence as optional. i.e. `?`
 * @param patternOrCombinator - The pattern to apply
 */
export declare const option: (patternOrCombinator: PatternCombinator) => Combinator;
/**
 * A Combinator to make the provided pattern's occurrence as any or more, i.e. `*`
 * @param patternOrCombinator - The pattern to apply
 */
export declare const any: (patternOrCombinator: PatternCombinator) => Combinator;
/**
 * A Combinator to make the provided pattern's occurrence as in specified range.
 * i.e. `{min,max}`
 * @param patternOrCombinator - The pattern to apply
 * @param min - The minimum occurrence
 * @param max - The Maximum occurrence, `undefined` means unlimited
 */
export declare const range: (patternOrCombinator: PatternCombinator, min: number, max?: number) => Combinator;
/**
 * A Combinator to make the provided patterns as a combination of alternatives
 * @param patternOrCombinators - The combination of alternatives, e.g. `a|b|c`
 */
export declare const alt: (...patternOrCombinators: PatternCombinator[]) => Combinator;
/**
 * A Combinator to join the provided patterns as a single pattern
 * @param patternOrCombinators - The patterns to join.
 */
export declare const join: (...patternOrCombinators: PatternCombinator[]) => Combinator;
/**
 * A Combinator for the match start of a string.
 * @param patternOrCombinators - The patterns to be applied.
 */
export declare const begin: (patternOrCombinator: PatternCombinator) => Combinator;
/**
 * A Combinator for the match end of a string.
 * @param patternOrCombinators - The patterns to be applied.
 */
export declare const end: (patternOrCombinator: PatternCombinator) => Combinator;
/*******************************************************************************
 * Tokenizer
 ******************************************************************************/
/**
 * Parser interface
 */
interface Parser<T> {
    /**
     * Print the pattern used for the parsing
     */
    print(): string;
    /**
     * Parse the provided string
     * @param str - The string to be parsed
     * @returns `null` when not matching the pattern, otherwise an object as
     * defined by the pattern for the match
     */
    parse(str: string): T;
}
/**
 * A tokenizer for building the pattern for parsing
 */
interface Tokenizer<T> {
    /**
     * Append the provided pattern for building up the accumulated patterns
     * @param patternOrCombinator - Can a string or a combinator function, e.g `group()`
     */
    push(patternOrCombinator: PatternCombinator): Tokenizer<T>;
    /**
     * Put the provided `start` pattern to the start of the accumulated patterns
     * or put the provided `end` pattern to the end of the accumulated patterns
     *
     * @param start - Can a string or a combinator function, e.g `group()`
     * @param end - Can a string or a combinator function, e.g `group()`
     */
    between(start?: PatternCombinator, end?: PatternCombinator): Tokenizer<T>;
    /**
     * Build and finalize the patterns and return a Parser @see {@link Parser}
     */
    build(): Parser<T>;
}
interface Matched<T> {
    list: ArrayLike<string | number>;
    groups?: T;
}
export declare const createTokenizer: <T extends Record<string, unknown>>() => Tokenizer<Matched<T> | null>;
export {};
