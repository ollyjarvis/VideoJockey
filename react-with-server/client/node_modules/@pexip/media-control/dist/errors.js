import { isMediaTrackConstraints } from './typeGuards';
import { extractDeviceId } from './constraints';
import { MediaDeviceFailure } from './types';
const isDeviceInUseError = (error) => {
    return (error === MediaDeviceFailure.NotReadableError ||
        error === MediaDeviceFailure.TrackStartError);
};
const isPermissionDeniedError = (error) => {
    return (error === MediaDeviceFailure.NotAllowedError ||
        error === MediaDeviceFailure.PermissionDeniedError);
};
export const isInputNotFoundError = ({ input, kind, devices }) => (error) => {
    if (error === MediaDeviceFailure.NotFoundError) {
        const hasDevices = devices.some(d => d.kind === kind);
        if (typeof input === 'boolean') {
            if (!hasDevices && input) {
                return true;
            }
            return input && !hasDevices;
        }
        if (isMediaTrackConstraints(input)) {
            const [deviceIds, requirement] = extractDeviceId(input);
            if (requirement === 'ideal') {
                return !hasDevices;
            }
            if (requirement === 'exact') {
                return !devices.some(device => deviceIds?.some(id => device.kind === kind && id === device.deviceId));
            }
        }
    }
    return false;
};
const normalizeError = (errors, parameters = []) => {
    const error = errors.find(e => e.fn(...parameters));
    if (error) {
        return error.type;
    }
    return false;
};
export const normalizeGetUserMediaError = (browserError, constraints, devices) => {
    const isAudioInputNotFoundError = isInputNotFoundError({
        input: constraints.audio,
        kind: 'audioinput',
        devices,
    });
    const isVideoInputNotFoundError = isInputNotFoundError({
        input: constraints.video,
        kind: 'videoinput',
        devices,
    });
    const areBothInputsNotFoundError = (error) => isAudioInputNotFoundError(error) && isVideoInputNotFoundError(error);
    const errorsFn = [
        {
            fn: isDeviceInUseError,
            type: MediaDeviceFailure.NotReadableError, // For now just normalize to current spec
        },
        {
            fn: isPermissionDeniedError,
            type: MediaDeviceFailure.NotAllowedError,
        },
        {
            fn: areBothInputsNotFoundError,
            type: MediaDeviceFailure.AudioAndVideoDeviceNotFoundError,
        },
        {
            fn: isAudioInputNotFoundError,
            type: MediaDeviceFailure.AudioInputDeviceNotFoundError,
        },
        {
            fn: isVideoInputNotFoundError,
            type: MediaDeviceFailure.VideoInputDeviceNotFoundError,
        },
    ];
    const errorMsg = browserError.name === 'Error'
        ? browserError.message
        : browserError.name;
    const error = normalizeError(errorsFn, [errorMsg]);
    return error ? error : errorMsg;
};
export const normalizeDeviceError = ({ audio, video, streamingAudioInput, streamingVideoInput, }) => {
    let audioError = false;
    let videoError = false;
    if (audio) {
        audioError = !streamingAudioInput;
    }
    if (video) {
        videoError = !streamingVideoInput;
    }
    const errorsFn = [
        {
            fn: () => audioError && videoError,
            type: MediaDeviceFailure.AudioAndVideoDeviceNotFoundError,
        },
        {
            fn: () => audioError,
            type: MediaDeviceFailure.AudioInputDeviceNotFoundError,
        },
        {
            fn: () => videoError,
            type: MediaDeviceFailure.VideoInputDeviceNotFoundError,
        },
    ];
    const error = normalizeError(errorsFn, []);
    return error ? error : false;
};
