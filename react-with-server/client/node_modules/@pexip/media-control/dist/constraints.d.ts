import type { FacingMode, InputConstraintSet, InputDeviceConstraint, MediaConstraintRequirement, MediaDeviceInfoLike, MediaDeviceRequest, NormalizedConstraintDeviceParameters } from './types';
import type { ConstrainBooleanKeys, ConstrainDoubleKeys, ConstrainParamKeys, ConstrainRangeParamKeys, ConstrainStringKeys, ConstrainULongKeys, ExtendedConstrainBooleanKeys, ExtendedConstrainDoubleKeys, ExtendedConstrainStringKeys, ExtendedConstrainULongKeys } from './typeGuards';
/**
 * Check if provided constraint is an `exact` device constraint
 */
export declare const isExactDeviceConstraint: (constraint: InputDeviceConstraint | undefined) => boolean;
/**
 * Use navigator.mediaDevices.getSupportedConstraints to remove constraints not supported by agent.
 * Creates a copy of MediaStreamConstraints with only supported properties.
 */
export declare const removeUnsupportedConstraints: (constraints: MediaStreamConstraints) => MediaStreamConstraints;
/**
 * Merge base constraints with provided base constraints and another constraints
 */
export declare const mergeConstraints: (baseConstraints: InputConstraintSet | boolean | undefined) => (constraints: InputDeviceConstraint | undefined) => InputConstraintSet | boolean;
/**
 * Normalize Device
 * Convert any valid `MediaDeviceInfoLike` into `MediaDeviceInfoLike[]`
 *
 * Check test cases for the details
 */
export declare const normalizeDevice: (device: InputConstraintSet['device']) => MediaDeviceInfo[] | undefined;
/**
 * Normalize Device Constraint
 * Convert Device Constraints into a form of `ConstraintDeviceParameters`
 * e.g.
 * `{ideal?: MediaDeviceInfoLike[], exact?: MediaDeviceInfoLike[]}`
 *
 * Check test cases for the details
 *
 * @returns
 * `undefined` if nothing is meaningful for the constraint, otherwise,
 * a normalized form of `ConstraintDeviceParameters`
 */
export declare const normalizeDeviceConstraint: (constraints: InputConstraintSet['device']) => NormalizedConstraintDeviceParameters | undefined;
/**
 * Convert `InputConstraintSet['device']` into
 * `MediaTrackConstraintSet['deviceId']` in a normalized form
 */
export declare const toDeviceIdConstraintSet: (constraint: InputConstraintSet['device']) => MediaTrackConstraints['deviceId'];
export declare const toArray: <T>(t: T | T[]) => T[];
export type ConstrainNoneTuple = [undefined, 'ideal'];
export declare const NONE: ConstrainNoneTuple;
export type ConstrainStringTuple = [string[], ConstrainParamKeys];
export declare const extractConstrainString: (key: ConstrainStringKeys | ExtendedConstrainStringKeys) => (constraints: InputConstraintSet) => ConstrainStringTuple | ConstrainNoneTuple;
export type ConstrainBooleanTuple = [boolean, ConstrainParamKeys];
export declare const extractConstrainBoolean: (key: ConstrainBooleanKeys | ExtendedConstrainBooleanKeys) => (constraints: InputConstraintSet) => ConstrainBooleanTuple | ConstrainNoneTuple;
export type ConstrainNumber = number | Partial<Record<ConstrainRangeParamKeys, number>>;
export type ConstrainNumberTuple = [
    ConstrainNumber,
    ConstrainParamKeys | 'min-max'
];
export declare const extractConstrainNumber: (key: ConstrainULongKeys | ConstrainDoubleKeys | ExtendedConstrainULongKeys | ExtendedConstrainDoubleKeys) => (constraints: InputConstraintSet) => ConstrainNumberTuple | ConstrainNoneTuple;
export type ConstrainDeviceTuple = [MediaDeviceInfoLike[], ConstrainParamKeys];
export declare const extractConstrainDevice: (constraints: InputDeviceConstraint | undefined) => ConstrainDeviceTuple | ConstrainNoneTuple;
/**
 * Compare float point number a and b to see if they are closed to be considered
 * as having the same value
 *
 * @param a - Floating point number a
 * @param b - Floating point number b
 * @param numDigits - The number of digits to check after the decimal point @defaultValue 5 digits
 */
export declare const closedTo: (a: number, b: number, numDigits?: number) => boolean;
/**
 * Check if provided num is between min (inclusive) and max (inclusive)
 *
 * @param min - Lower boundary of the checking
 * @param num - The number used for the checking
 * @param max - Upper boundary of the checking
 */
export declare const between: (min: number | undefined, num: number, max: number | undefined) => boolean;
export declare const getValueFromConstrainNumber: (constraint: ConstrainNumber) => number;
export declare const getFacingModeFromConstraintString: (constraint: string) => FacingMode | undefined;
/**
 * Compare the provided constraint and num and see if the num satisfy the
 * constraint
 *
 * @param constraint - The constraint to be used
 * @param num - The num to be used to check
 *
 * @returns `true` means satisfy otherwise `false`
 */
export declare const satisfyConstrainNumber: (constraint: ConstrainNumber | undefined, num: number | undefined) => boolean;
/**
 * Resolve *constraints* and mediaTrackConstraints by checking the type and
 * try to return the best possible from mediaTrackConstraints.
 *
 * @internal
 */
export declare const resolveMediaDeviceConstraints: (constraints?: InputDeviceConstraint, base?: MediaTrackConstraints | boolean) => MediaTrackConstraints | boolean;
/**
 * @remarks
 * Constraint multiple (exact) devices is not supported
 *
 * @internal
 */
export declare const getMediaConstraints: ({ audio, video, defaultConstraints, }: MediaConstraintRequirement) => MediaStreamConstraints;
/**
 * Call applyConstraints foreach track accordingly
 *
 * @param tracks - Tracks to be applied
 * @param constraints - constraints to be applied
 */
export declare const applyConstraints: (tracks: MediaStreamTrack[] | undefined, constraints: MediaDeviceRequest) => Promise<void>;
export declare const findDeviceFrom: (devicesToFind: MediaDeviceInfoLike[], deviceList: MediaDeviceInfoLike[]) => MediaDeviceInfoLike[] | undefined;
export declare const findDeviceFromDeviceConstraints: (device: InputConstraintSet['device'], devices: MediaDeviceInfoLike[]) => MediaDeviceInfoLike[] | undefined;
export declare const relaxDevice: (device: InputConstraintSet['device'], devices: MediaDeviceInfoLike[]) => MediaDeviceInfoLike[] | undefined;
export declare const resolveOnlyDevice: (devices: MediaDeviceInfoLike[]) => true | MediaDeviceInfoLike | undefined;
type ConstrainNumberKeys = ConstrainULongKeys | ConstrainDoubleKeys | ExtendedConstrainDoubleKeys | ExtendedConstrainULongKeys;
type ConstrainTuples = ConstrainDeviceTuple | ConstrainNumberTuple | ConstrainStringTuple | ConstrainBooleanTuple | ConstrainNoneTuple;
type ExtractConstraintFn<R extends ConstrainTuples> = (constraints: InputDeviceConstraint | undefined) => R;
export declare function extractConstraints<T extends 'device'>(key: T): ExtractConstraintFn<ConstrainDeviceTuple>;
export declare function extractConstraints<T extends ConstrainStringKeys | ExtendedConstrainStringKeys>(key: T): ExtractConstraintFn<ConstrainStringTuple>;
export declare function extractConstraints<T extends ConstrainNumberKeys>(key: T): ExtractConstraintFn<ConstrainNumberTuple>;
export declare function extractConstraints<T extends ConstrainBooleanKeys | ExtendedConstrainBooleanKeys>(key: T): ExtractConstraintFn<ConstrainBooleanTuple>;
type ConstrainStrings = Record<ConstrainStringKeys | ExtendedConstrainStringKeys, ConstrainStringTuple | ConstrainNoneTuple>;
type ConstrainNumbers = Record<ConstrainNumberKeys, ConstrainNumberTuple | ConstrainNoneTuple>;
type ConstrainBooleans = Record<ConstrainBooleanKeys | ExtendedConstrainBooleanKeys, ConstrainBooleanTuple | ConstrainNoneTuple>;
type ConstrainDevices = Record<'device', ConstrainDeviceTuple | ConstrainNoneTuple>;
type Constraints = ConstrainStrings & ConstrainNumbers & ConstrainBooleans & ConstrainDevices;
/**
 * Extract the constraints with provided keys
 *
 * @param keys - The keys to be used for the extraction
 * @param constraints - The constraints to be used for the extraction
 *
 * @returns an object with the provided key and the value-param tuple
 *
 * @example
 *
 * ```typescript
 * const device = {deviceId: 'xxxx', label: 'abc', kind: 'audioinput'};
 * const constraints = { device, noiseSuppression: true };
 * const extract = extractConstraintsWithKeys(['device', 'noiseSuppression']);
 * const {
 *   device: [devices, deviceParam],
 *   noiseSuppression: [noiseSuppression, noiseSuppressionParam],
 * } = extract(constraints);
 * expect(devices).toEqual([device]);
 * expect(deviceParam).toEqual('ideal');
 * expect(noiseSuppression).toEqual(true);
 * expect(noiseSuppressionParam).toEqual('ideal');
 * ```
 */
export declare const extractConstraintsWithKeys: <T extends "deviceId" | "groupId" | "device" | "videoSegmentation" | "videoSegmentationModel" | "denoise" | "vad" | "asd" | "mixWithAdditionalMedia" | "backgroundImageUrl" | "resizeMode" | "pan" | "tilt" | "zoom" | "contentHint" | "facingMode" | "echoCancellation" | "autoGainControl" | "noiseSuppression" | ConstrainNumberKeys>(keys: readonly T[]) => (constraints: InputDeviceConstraint | undefined) => Pick<Constraints, T>;
/**
 * Extract deviceId from constraints
 */
export declare const extractDeviceId: (constraints: InputConstraintSet) => ConstrainStringTuple | ConstrainNoneTuple;
/**
 * Find device from the device list with provided constraints
 *
 * @param constraints - The constraints to be used for the lookup
 * @param devices - The devices to be used for the lookup
 *
 * @returns `true` means it can be any devices, `undefined` means not found,
 * otherwise, the matched device will be returned
 */
export declare const findDeviceFromConstraints: (constraints: InputDeviceConstraint | undefined, devices: MediaDeviceInfoLike[]) => boolean | MediaDeviceInfoLike | undefined;
/**
 * Relax input constraints to enable looking up the device by `deviceId` as well
 * as `label` as a fallback as a best effort to get a similar device when
 * possible.
 *
 * @param input - The input constraints to be relaxed
 * @param devices - The current device list
 */
export declare const relaxInputConstraint: (input: InputDeviceConstraint | undefined, devices: MediaDeviceInfoLike[]) => InputDeviceConstraint | undefined;
export declare const getConstraintsHandlers: () => {
    getDefaultConstraints: () => MediaStreamConstraints;
    setDefaultConstraints: (newConstraints: MediaStreamConstraints) => void;
};
export {};
