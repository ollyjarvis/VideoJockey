import type { DataChannelConfig, DataChannelInit, ExtendedRTCPeerConnection, LogFn, MediaConfig, MediaDirection, MediaInit, OnTransceiverChangeHandler, PCOptionalsSignals, PCSignals, PeerConnection, PeerConnectionSignals, RTCPeerConnectionEventListeners, References, TransceiverConfig, TransceiverInit } from './types';
import type { TransceiverMediaType } from './constants';
/**
 * create a logger with reference attached
 *
 * @param getRefs - A function to the references for logging
 */
export declare const createRefsLog: (getRefs: () => Record<string, unknown>) => {
    debug: LogFn;
    info: LogFn;
    error: LogFn;
    warn: LogFn;
};
/**
 * Get the states from RTCPeerConnection
 *
 * @param pc - the peer connection to get the states
 */
export declare const getPeerConnectionStates: (pc: PeerConnection | ExtendedRTCPeerConnection) => {
    readonly connectionState: RTCPeerConnectionState;
    readonly iceConnectionState: RTCIceConnectionState;
    readonly iceGatheringState: RTCIceGatheringState;
    readonly signalingState: RTCSignalingState;
};
/**
 * Get common states and props from PeerConnection
 *
 * @param pc - The peer connection to get the info
 */
export declare const getStatesAndProps: (pc: PeerConnection) => {
    offerOptions: RTCOfferOptions | undefined;
    answerOptions: RTCAnswerOptions | undefined;
    connectionState: RTCPeerConnectionState;
    iceConnectionState: RTCIceConnectionState;
    iceGatheringState: RTCIceGatheringState;
    signalingState: RTCSignalingState;
};
export declare const logReferences: (refs: References) => {
    module: string | undefined;
    references: References;
};
export declare const createGetRefs: (pc: PeerConnection) => () => {
    offerOptions: RTCOfferOptions | undefined;
    answerOptions: RTCAnswerOptions | undefined;
    connectionState: RTCPeerConnectionState;
    iceConnectionState: RTCIceConnectionState;
    iceGatheringState: RTCIceGatheringState;
    signalingState: RTCSignalingState;
    module: string | undefined;
    references: References;
};
/**
 * Compare the provided 2 streams to check if they are the same
 * @param stream1 - the stream to compare
 * @param stream2 - the stream to compare
 */
export declare const isSameStream: (stream1?: MediaStream, stream2?: MediaStream) => boolean | undefined;
/**
 * Wire the peer connection event with the pre-defined handler and signal
 * accordingly
 *
 * @param wireOptions - Wire event params
 * + `key` - event key
 * + `pc` - peer connection
 * + `signal` - the signal to wire
 */
export declare const wirePeerConnectionEventHandler: <T extends keyof PeerConnectionSignals>({ key, pc, signal, }: {
    key: T;
    pc: PeerConnection;
    signal: PeerConnectionSignals[T];
}) => void;
/**
 * Wire the peer connection events with provided signals
 *
 * @param pc - peer connection
 * @param signals - the set of signals to wire
 */
export declare const wirePeerConnectionEvents: (pc: PeerConnection, signals: Partial<PeerConnectionSignals>) => void;
/**
 * Create a general signal with consistent scoped name
 *
 * @param name - Signal name
 * @param crucial - Signify if the signal is unmissable.
 */
export declare const createPCSignal: <T = undefined>(name: string, crucial?: boolean) => import("@pexip/signal").Signal<T>;
export declare const REQUIRED_SIGNAL_KEYS: readonly ["onOfferRequired", "onReceiveAnswer", "onReceiveOffer", "onOffer", "onOfferIgnored", "onAnswer", "onError"];
/**
 * Create and return all required and optional (if specified with `more`),
 * signals for peer connection to work
 *
 * @param more - Keys from `PCOptionalsSignals`, @see PCOptionalsSignals
 * @param scope - any scope prefix for the generated signal name, @see Signal
 *
 * The following signals created by default
 *  'onOfferRequired',
 *  'onReceiveAnswer',
 *  'onReceiveOffer',
 *  'onOffer',
 *  'onAnswer',
 *  'onError',
 * @see REQUIRED_SIGNAL_KEYS
 */
export declare const createPCSignals: <K extends "onReceiveIceCandidate" | keyof PeerConnectionSignals>(more: K[], scope?: string) => Pick<import("./types").CorePeerConnectionSignals & Omit<import("./types").PeerConnectionCommandSignals, "onReceiveIceCandidate"> & Required<PCOptionalsSignals>, "onOfferRequired" | "onReceiveAnswer" | "onReceiveOffer" | "onOffer" | "onOfferIgnored" | "onAnswer" | "onError" | K>;
/**
 * Handle some core signals for the peer connection.
 *
 * @param peer - The peer connection
 *
 * @returns the signal subscriptions which are needed to be called when closing
 * the peer connection
 */
export declare const withSignals: (peer: PeerConnection) => ({ onReceiveAnswer, onReceiveIceCandidate, onReceiveOffer, onOffer, onOfferIgnored, onAnswer, onError, onNegotiationNeeded, onIceCandidateError, ...pcEventSignals }: Omit<PCSignals, 'onOfferRequired'>) => import("@pexip/signal").Detach[];
/**
 *  workaround to allow echo cancellation in Chromium browsers, due to https://bugs.chromium.org/p/chromium/issues/detail?id=687574.
 *
 * based on https://dev.to/focusedlabs/echo-cancellation-with-web-audio-api-and-chromium-1f8m
 *  and https://gist.github.com/alexciarlillo/4b9f75516f93c10d7b39282d10cd17bc
 */
export declare const getCreateLoopbackConnectionFn: (rtcConnection?: RTCPeerConnection, rtcLoopbackConnection?: RTCPeerConnection, loopbackStream?: MediaStream) => (stream: MediaStream) => Promise<MediaStream>;
export declare const isTransceiverMediaType: (mediaType: unknown) => mediaType is "audio" | "video";
export declare const isMediaType: (t: unknown) => t is "audio" | "video" | "application";
export declare const assertTransceiverMediaType: (mediaType: unknown) => "audio" | "video";
export declare const resolveKindOrTrack: (kindOrTrack: MediaStreamTrack | TransceiverMediaType | undefined) => Pick<TransceiverConfig, 'kind' | 'track'>;
export declare const isTransceiverObsolete: (transceiver: RTCRtpTransceiver) => boolean;
/**
 * Compare 2 flat records (an object with primitive type) using Object.is comparator
 *
 * @remarks No deep comparison
 */
export declare const compareRecord: <T extends object>(record1: T | undefined, record2: T | undefined) => boolean;
/**
 * Compare 2 Array and using the provided predicate to compare
 */
export declare const compareArray: <T>(list1: T[] | undefined, list2: T[] | undefined, predicate: (a: T | undefined, b: T | undefined) => boolean) => boolean;
/**
 * Merge two array and overwriting the old on with the new one in order
 */
export declare const merge: <T extends object[]>(oldParam: T, newParam: T) => RTCRtpEncodingParameters[];
export declare const isTransceiverInit: (t: unknown) => t is TransceiverInit;
export declare const isTransceiverConfig: (t: unknown) => t is TransceiverConfig;
export declare const isDataChannelInit: (t: unknown) => t is DataChannelInit;
export declare const isDataChannelConfig: (t: unknown) => t is DataChannelConfig;
export declare const isMediaInit: (t: unknown) => t is MediaInit;
export declare const isMediaConfig: (t: unknown) => t is MediaConfig;
export declare const createMediaConfigs: (mediaInits?: MediaInit[], onTransceiverChanged?: OnTransceiverChangeHandler) => {
    readonly configs: (TransceiverConfig | DataChannelConfig)[];
    addConfig: {
        (peer: RTCPeerConnection, initOrConfig: DataChannelInit | DataChannelConfig): DataChannelConfig;
        (peer: RTCPeerConnection, initOrConfig: TransceiverInit | TransceiverConfig): TransceiverConfig;
    };
    getConfig: {
        (key: RTCRtpTransceiver): TransceiverConfig | undefined;
        (key: RTCDataChannel): DataChannelConfig | undefined;
    };
    find: (predicate: (config: TransceiverConfig | DataChannelConfig) => boolean) => TransceiverConfig | DataChannelConfig | undefined;
};
/**
 * Try to derive the direction from `currentDirection` and the `intendedDirection`
 */
export declare const changeTransceiverDirection: (currentDirection: RTCRtpTransceiverDirection, intendedDirection?: 'send' | 'recv' | MediaDirection) => MediaDirection;
/**
 * Get the relative direction so you can get the correct direction, e.g.
 * `"sendonly" <--> "recvonly"`
 *
 * From https://www.rfc-editor.org/rfc/rfc3264.html#section-6.1
 * \> If a stream is offered as sendonly, the corresponding stream MUST be
 * \> marked as recvonly or inactive in the answer.  If a media stream is
 * \> listed as recvonly in the offer, the answer MUST be marked as
 * \> sendonly or inactive in the answer.  If an offered media stream is
 * \> listed as sendrecv (or if there is no direction attribute at the
 * \> media or session level, in which case the stream is sendrecv by
 * \> default), the corresponding stream in the answer MAY be marked as
 * \> sendonly, recvonly, sendrecv, or inactive.  If an offered media
 * \> stream is listed as inactive, it MUST be marked as inactive in the
 * \> answer.
 */
export declare const getRelativeDirection: (remoteDirection: MediaDirection | undefined) => MediaDirection;
export declare const deriveSendDirectionFromTrack: (intendedDirection: MediaDirection, track: MediaStreamTrack | undefined | null) => MediaDirection;
/**
 * Create a queue to handle buffering and trigger provided `callback` being
 * called in order.
 *
 * @param callback - The callback being called
 */
export declare const createEventQueue: <T>(callback: (item: T) => void) => {
    buffering: boolean;
    readonly length: number;
    readonly items: T[];
    /**
     * Put an item to the end of the queue. When the attribute `buffering`
     * is `false`, it triggers the `callback` immediately instead of putting
     * the item into the queue.
     *
     * @param item - The item to put into the queue
     */
    enqueue: (item: T) => void;
    /**
     * Empty the queue by running the callback with all the items in the
     * queue in-order, and returns the items;
     */
    flush: () => T[];
    /**
     * Discard all the items without any side effects
     */
    discard: () => void;
};
export declare const subscribePCEvents: (pc: RTCPeerConnection, listeners: RTCPeerConnectionEventListeners) => void;
/**
 * A wrapper to create a RTCPeerConnection instance and subscribe the events
 * declared from the provided list of `listeners`.
 *
 * @param options - The configuration for the `RTCPeerConnection`
 * @param listeners - A list of listeners to listen on the Peer Connection
 * events
 * @param existingPC - Instead of creating a new Peer Connection, it always uses
 * this instance instead.
 */
export declare const createRTCPeerConnection: (options?: RTCConfiguration, listeners?: RTCPeerConnectionEventListeners, existingPC?: RTCPeerConnection) => ExtendedRTCPeerConnection;
