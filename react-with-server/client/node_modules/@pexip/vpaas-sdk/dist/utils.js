import { Backoff } from '@pexip/utils';
import { createSignal } from '@pexip/signal';
import { BadRequestError, GoneError, NotFoundError } from '@pexip/vpaas-api';
import { createSocketSignals as createSS } from '@pexip/socket-manager';
import { BACKOFF_BASE_SETTINGS, MAX_RECONNECT_ATTEMPTS } from './constants';
import { logger } from './logger';
export const createVpaasSignals = () => ({
    onRosterUpdate: createSignal({
        name: 'mee:onRosterUpdate',
    }),
    onMediaOffer: createSignal({
        name: 'mee:onMediaOffer',
    }),
    onReconnecting: createSignal({
        name: 'mee:reconnecting',
    }),
    onReconnected: createSignal({
        name: 'mee:reconnecting',
    }),
    onRemoteStreams: createSignal({
        name: 'mee:onRemoteStreams',
    }),
    onError: createSignal({
        name: 'mee:onError',
    }),
});
export const createSocketSignals = () => createSS();
export const createRecvTransceivers = (kind, length, content) => Array.from({ length }, () => ({
    direction: 'recvonly',
    kindOrTrack: kind,
    content,
}));
export const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
const ANONYMOUS_FN = 'Anonymous';
const getName = (observer) => {
    return observer.name || ANONYMOUS_FN;
};
export const retriable = async (fn, backoff = new Backoff(BACKOFF_BASE_SETTINGS), retries = MAX_RECONNECT_ATTEMPTS) => {
    try {
        return await fn();
    }
    catch (error) {
        if (error instanceof Error && error.name === 'AbortError') {
            logger.warn({ error }, `${getName(fn)} aborted`);
            throw error;
        }
        if (retries === 0) {
            logger.error({ error }, `${getName(fn)} failed`);
            throw error;
        }
        if (error instanceof BadRequestError) {
            logger.warn({ error }, `${getName(fn)} has bad request. No point of retrying`);
            throw error;
        }
        if (error instanceof NotFoundError) {
            logger.warn({ error }, `${getName(fn)} not found. No point of retrying`);
            throw error;
        }
        if (error instanceof GoneError) {
            logger.warn({ error }, `${getName(fn)} gone. No point of retrying`);
            throw error;
        }
        logger.error({ error, retries }, `retrying ${getName(fn)}`);
        await sleep(backoff.duration());
        return await retriable(fn, backoff, retries - 1);
    }
};
export const isSendConfig = (config) => config.direction === 'sendonly';
export const isInactiveConfig = (config) => config.direction === 'inactive';
export const isRecvConfig = (config) => config.direction === 'recvonly';
export const isMainConfig = (config) => config.content === 'main';
export const isPresoConfig = (config) => config.content === 'slides';
export const isAudioConfig = (config) => config.kind === 'audio';
export const isVideoConfig = (config) => config.kind === 'video';
export const isMainSendConfig = (config) => [isMainConfig, isSendConfig].every(fn => fn(config));
export const isPresoInactiveConfig = (config) => [isPresoConfig, isInactiveConfig].every(fn => fn(config));
export const isPresoRecvConfig = (config) => [isPresoConfig, isRecvConfig].every(fn => fn(config));
export const isPresoSendConfig = (config) => [isPresoConfig, isSendConfig].every(fn => fn(config));
export const isPresoVideo = (config) => [isPresoConfig, isVideoConfig].every(fn => fn(config));
export class WebsocketError extends Error {
    constructor(message) {
        super(message);
        this.name = 'WebsocketError';
    }
}
export class ResourceUnavailableError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ResourceUnavailableError';
    }
}
export class MeetingFullError extends Error {
    constructor(message) {
        super(message);
        this.name = 'MeetingFullError';
    }
}
export { BadRequestError, GoneError, NotFoundError, };
const TRACE_CHARS = '0123456789abcdef';
const getRandomString = (length, chars = TRACE_CHARS) => Array.from({ length }, (_, i) => i).reduce(acc => acc + chars[(Math.random() * chars.length) | 0], '');
export const getTraceparent = () => `00-${getRandomString(32)}-${getRandomString(16)}-01`;
export const isResponseError = (error) => {
    if (error &&
        typeof error === 'object' &&
        'type' in error &&
        error.type === 'error' &&
        'error_type' in error &&
        'error_message' in error) {
        return true;
    }
    return false;
};
//# sourceMappingURL=utils.js.map