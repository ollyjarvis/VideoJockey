import type { MediaDeviceRequest, MediaDeviceInfoLike } from '@pexip/media-control';
import { UserMediaStatus } from './types';
import type { Media, MediaAttributes, Pipeline, Process, ProcessMedia, ExtendedMediaTrackSettingsKey, ExtendedMediaTrackSettings } from './types';
export declare const makeDeriveDeviceStatus: (constraints: MediaDeviceRequest) => (audio: UserMediaStatus, video: UserMediaStatus, both: UserMediaStatus) => UserMediaStatus;
export declare const createMediaProcess: (process: ProcessMedia) => Process<Promise<Media>>;
export declare const createMediaPipeline: <T = MediaDeviceRequest>(init: Pipeline<T> | (() => Pipeline<T>)) => {
    pipe: (process: Process<Promise<Media>>) => void;
    execute: (m: T) => Promise<Media>;
};
/**
 * Interpret provided input to resolve to a MediaDeviceInfoLike when possible
 * otherwise `undefined`
 */
export declare const interpretInput: (input: boolean | MediaDeviceInfoLike | undefined, getCurrentInput: () => MediaDeviceInfoLike | undefined) => MediaDeviceInfoLike | undefined;
type InputConstraints = MediaDeviceRequest['audio'];
interface MediaInputInfo {
    devices: MediaDeviceInfoLike[];
    input: MediaDeviceInfoLike | undefined;
}
/**
 * Memorized Expected Input
 */
export declare const createMemorizedGetExpectedInput: () => (constraints: InputConstraints, getInfo: () => MediaInputInfo) => ExpectedInput;
/**
 * A utility function to check if the provided track is muted. There are
 * 2 factors to be considered: `MediaStreamTrack['muted']` and `MediaStreamTrack['enabled']`.
 *
 * ```
 * | muted \ enabled | true  | false |
 * |-----------------| ----- | ----- |
 * |     true        | true  | true  |
 * |     false       | false | true  |
 * ```
 *
 * @param tracks - The tracks can be got from `MediaStream['getAudioStats']` or
 * `MediaStream['getVideoTracks']`
 *
 * @returns `true` means muted, `false` means not muted and `undefined` means
 * there is no track to check
 */
export declare const isMuted: (tracks: MediaStreamTrack[] | undefined) => boolean | undefined;
type ExpectedInput = MediaDeviceInfoLike | undefined;
export declare const buildMedia: (getMedia: () => Partial<Media>, onSetStatus?: ((status: UserMediaStatus) => void) | undefined) => Media;
/**
 * Clone the media from the rawStream (if any), otherwise, stream
 */
export declare const cloneMedia: (media: Media) => Promise<Media>;
/**
 * Shallow copy the provided object and override with provided overriding
 *
 * @param original - Original object
 * @param overriding - Object of the same type to override the original
 *
 * @returns a shallow copied object
 */
export declare const shallowCopy: <T>(original: T, overriding: Partial<T>) => T;
export declare const getDevicesChanges: (prev: MediaDeviceInfoLike[], next: MediaDeviceInfoLike[]) => {
    unauthorized: MediaDeviceInfoLike[];
    authorized: MediaDeviceInfoLike[];
    found: MediaDeviceInfoLike[];
    lost: MediaDeviceInfoLike[];
    devices: MediaDeviceInfoLike[];
};
/**
 * Apply Extended constraints on top of the original
 *
 * @param media - The media from the media pipeline
 * @param applyExtended - The function to be called when the previous
 * `applyConstraints` is done
 */
export declare const applyExtendedConstraints: (media: Media, applyExtended: (constraints: MediaDeviceRequest) => Promise<void>) => (constraints: MediaDeviceRequest) => Promise<void>;
export declare const AUDIO_SETTINGS_KEYS: ExtendedMediaTrackSettingsKey[];
export declare const VIDEO_SETTINGS_KEYS: ExtendedMediaTrackSettingsKey[];
export declare const MIXING_SETTINGS_KEYS: ExtendedMediaTrackSettingsKey[];
export declare const hasSettingsChanged: (keysToLookFor: ExtendedMediaTrackSettingsKey[]) => (settingsA: ExtendedMediaTrackSettings | undefined, settingsB: ExtendedMediaTrackSettings | undefined) => boolean;
export declare const toJSON: (media: Partial<MediaAttributes>) => {
    constraints: MediaDeviceRequest | undefined;
    devices: MediaDeviceInfoLike[] | undefined;
    stream: MediaStream | undefined;
    rawStream: MediaStream | undefined;
    audioInput: MediaDeviceInfoLike | undefined;
    videoInput: MediaDeviceInfoLike | undefined;
    expectedAudioInput: MediaDeviceInfoLike | undefined;
    expectedVideoInput: MediaDeviceInfoLike | undefined;
    status: UserMediaStatus | undefined;
    audioMuted: boolean | undefined;
    videoMuted: boolean | undefined;
};
export declare const wrapToJSON: (media: Media) => Media;
/**
 * A function to get the blur kernel size of image height
 *
 * @param percentage - The percentage of image height to calculate the blur
 * kernel size
 * @param height - The image height
 * @param max - The upper bound
 *
 * @returns blur kernel size
 */
export declare const getBlurKernelSize: (percentage: number, height: number, max?: number) => number;
/**
 * Apply the content hint to the track
 *
 * @param hint - Content hint
 * @param track - The track to be applied
 */
export declare const applyContentHint: <T extends "" | "speech" | "speech-recognition" | "music" | "motion" | "detail" | "text">(hint?: T | undefined) => (track: MediaStreamTrack) => void;
export {};
