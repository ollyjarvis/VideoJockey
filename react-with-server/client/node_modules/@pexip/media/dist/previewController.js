import { getUserMedia, hasChangedInput, isMediaDeviceInfo, } from '@pexip/media-control';
import { createAsyncQueue } from '@pexip/utils';
import { UserMediaStatus } from './types';
import { buildMedia, cloneMedia, createMediaPipeline, hasSettingsChanged, AUDIO_SETTINGS_KEYS, VIDEO_SETTINGS_KEYS, } from './utils';
import { isMedia } from './typeGuard';
import { createModuleLogger } from './logger';
import { isInitial } from './status';
import { createGetUserMediaProcess } from './userMedia';
const DEFAULT_QUEUE_SIZE = 1;
const DEFAULT_QUEUE_THROTTLE_MS = 500;
const DEFAULT_QUEUE_DELAY_MS = 100;
const DEFAULT_QUEUE_DROP_LAST = false;
const isPreviewInput = (value) => {
    if (isMediaDeviceInfo(value) || value === undefined) {
        return true;
    }
    return false;
};
const extractFeaturesToConstraints = (keysToLookFor, settings) => {
    if (!settings) {
        return {};
    }
    return keysToLookFor.reduce((set, key) => {
        if (settings[key] !== undefined) {
            return { ...set, [key]: settings[key] };
        }
        return set;
    }, {});
};
const createEventHandler = (eventHandlers) => (key) => (callback) => {
    eventHandlers[key] = callback;
    return () => {
        eventHandlers[key] = undefined;
    };
};
const getUM = async (constraints) => [
    await getUserMedia(constraints),
    UserMediaStatus.PermissionsGranted,
];
const createAudioVideoProcessingSettingsChangeDetector = (getCurrentMedia, getPreviewMedia) => {
    const hasAudioSettingsChanged = hasSettingsChanged(AUDIO_SETTINGS_KEYS);
    const hasVideoSettingsChanged = hasSettingsChanged(VIDEO_SETTINGS_KEYS);
    return () => {
        const currentMedia = getCurrentMedia?.();
        const previewMedia = getPreviewMedia();
        const { audio: [mainAudio], video: [mainVideo], } = currentMedia?.getSettings() ?? { audio: [], video: [] };
        const { audio: [previewAudio], video: [previewVideo], } = previewMedia.getSettings();
        const changed = hasAudioSettingsChanged(mainAudio, previewAudio) ||
            hasVideoSettingsChanged(mainVideo, previewVideo);
        return changed;
    };
};
export const createPreviewStreamController = ({ getCurrentDevices, getCurrentMedia, updateMainStream, onEnded, mediaSignal, queueOptions = {
    size: DEFAULT_QUEUE_SIZE,
    throttleInMS: DEFAULT_QUEUE_THROTTLE_MS,
    delayInMS: DEFAULT_QUEUE_DELAY_MS,
    dropLast: DEFAULT_QUEUE_DROP_LAST,
}, processors, }) => {
    const queue = createAsyncQueue(queueOptions);
    const eventHandlers = {};
    const release = () => {
        if (isInitial(props.media.status)) {
            props.discardMedia = true;
        }
        props.media = buildMedia(() => ({ release }));
        return Promise.resolve();
    };
    const internalProps = {
        media: buildMedia(() => ({ release })),
        updatingPreview: false,
        updatingMain: false,
        discardMedia: false,
        initialized: false,
    };
    const logger = createModuleLogger({
        module: 'PreviewStreamController',
        eventHandlers,
        props: internalProps,
    });
    const cleanUpMainSubscription = () => {
        if (eventHandlers.unsubscribeMain) {
            eventHandlers.unsubscribeMain();
            eventHandlers.unsubscribeMain = undefined;
        }
    };
    const props = new Proxy(internalProps, {
        get: (target, p) => {
            return target[p];
        },
        set: (target, p, value) => {
            if (target[p] === value) {
                return true;
            }
            logger.debug({ oldValue: target[p], newValue: value }, `Update Props[${p}]`);
            switch (p) {
                case 'media': {
                    if (!isMedia(value)) {
                        return false;
                    }
                    target[p] = value;
                    eventHandlers[p]?.(value);
                    // Unsubscribe main stream signal on change of inputs
                    cleanUpMainSubscription();
                    return true;
                }
                case 'audioInput':
                case 'videoInput': {
                    if (!isPreviewInput(value)) {
                        return false;
                    }
                    target[p] = value;
                    eventHandlers[p]?.(value);
                    return true;
                }
                case 'updatingMain':
                case 'updatingPreview': {
                    if (typeof value !== 'boolean') {
                        return false;
                    }
                    target[p] = value;
                    eventHandlers[p]?.(value);
                    return true;
                }
                default:
                    Reflect.set(target, p, value);
                    return true;
            }
        },
    });
    const postMediaPipeline = createMediaPipeline(
    // Ignore the type conversion between tuple and array
    processors);
    const initFromMain = (mainMedia) => {
        if (!mainMedia.stream) {
            return;
        }
        postMediaPipeline
            .execute(cloneMedia(mainMedia))
            .then(media => {
            props.media = media;
        })
            .catch((error) => {
            logger.error({ error }, 'Failed to post process media');
        })
            .finally(() => {
            props.initialized = true;
            if (props.discardMedia) {
                void props.media.release();
            }
        });
        props.audioInput = mainMedia.audioInput;
        props.videoInput = mainMedia.videoInput;
        props.originalMainAudioInput = mainMedia.audioInput;
    };
    const mainMedia = getCurrentMedia();
    if (mainMedia?.stream) {
        initFromMain(mainMedia);
    }
    else {
        eventHandlers.unsubscribeMain = mediaSignal.add(initFromMain);
    }
    const replaceMainStream = async (constraints) => {
        logger.debug({ constraints }, 'Replacing main stream');
        props.updatingMain = true;
        await updateMainStream(constraints);
        props.updatingMain = false;
    };
    const mediaPipeline = createMediaPipeline(() => [
        createGetUserMediaProcess(getUM, getCurrentDevices, {
            initialMedia: props.media,
            scope: 'PreviewStreamController',
        }),
        ...processors,
    ]);
    const updatePreviewMedia = async (constraints) => {
        logger.debug({ constraints }, 'Requesting a new preview stream');
        await props.media?.release();
        const media = await mediaPipeline.execute(constraints);
        if (props.discardMedia) {
            logger.debug('Discard media');
            return await media.release();
        }
        props.media = media;
    };
    const updateAudioInput = async (input) => {
        props.audioInput = input;
        const request = {
            audio: { device: { exact: input } },
            video: props.videoInput,
        };
        try {
            props.updatingPreview = true;
            await updatePreviewMedia(request);
        }
        catch (error) {
            if (error instanceof Error) {
                const errorName = error.name === 'Error' ? error.message : error.name;
                if (errorName === 'NotReadableError') {
                    try {
                        logger.debug({ input }, 'NotReadableError, trying to sync main stream AudioInput');
                        await replaceMainStream({
                            audio: input,
                            video: getCurrentMedia()?.videoInput,
                        });
                        await updatePreviewMedia(request);
                    }
                    catch (err) {
                        logger.warn({ error: err, input }, 'Unable to recover NotReadableError AudioInput for preview');
                        if (err instanceof Error) {
                            return eventHandlers.audioInputError?.(err);
                        }
                        throw err;
                    }
                }
                else {
                    logger.warn({ error, input }, 'Unable to update AudioInput for preview');
                    eventHandlers.audioInputError?.(error);
                }
            }
            else {
                logger.error({ error, input }, 'Unable to update AudioInput for preview');
                throw error;
            }
        }
        finally {
            props.updatingPreview = false;
        }
    };
    const updateVideoInput = async (input) => {
        props.videoInput = input;
        try {
            props.updatingPreview = true;
            await updatePreviewMedia({
                audio: props.audioInput,
                video: { device: { exact: input } },
            });
        }
        catch (error) {
            if (error instanceof Error) {
                logger.warn({ error, input }, 'Unable to update VideoInput for preview');
                return eventHandlers.videoInputError?.(error);
            }
            throw error;
        }
        finally {
            props.updatingPreview = false;
        }
    };
    const cleanup = async () => {
        logger.debug('Cleanup preview controller');
        await props.media.release();
        cleanUpMainSubscription();
        props.audioInput = undefined;
        props.videoInput = undefined;
        onEnded?.();
    };
    const hasChangedAudioInput = () => hasChangedInput(props.originalMainAudioInput, props.audioInput);
    const hasChangedVideoInput = () => hasChangedInput(getCurrentMedia()?.videoInput, props.videoInput);
    const hasAudioVideoProcessingSettingsChanged = createAudioVideoProcessingSettingsChangeDetector(getCurrentMedia, () => props.media);
    const hasChanges = () => hasChangedAudioInput() ||
        hasChangedVideoInput() ||
        hasAudioVideoProcessingSettingsChanged();
    const applyChanges = async (force = false) => {
        const { audioInput, videoInput } = props;
        const { audio: [previewAudio], video: [previewVideo], } = props.media.getSettings();
        if (force || hasChanges()) {
            const audioSettings = extractFeaturesToConstraints(AUDIO_SETTINGS_KEYS, previewAudio);
            const videoSettings = extractFeaturesToConstraints(VIDEO_SETTINGS_KEYS, previewVideo);
            // Omit the width & height settings from the preview so that the one
            // from the main can be applied
            delete videoSettings.width;
            delete videoSettings.height;
            logger.info({ audioInput, videoInput, audioSettings, videoSettings }, 'Apply changes to main');
            try {
                await replaceMainStream({
                    audio: { device: audioInput, ...audioSettings },
                    video: { device: videoInput, ...videoSettings },
                });
                props.originalMainAudioInput = props.audioInput;
            }
            catch (error) {
                if (error instanceof Error) {
                    logger.warn({ error }, 'Unable to apply changes to main');
                    return eventHandlers.applyChangesError?.(error);
                }
                throw error;
            }
        }
    };
    const revertChanges = async () => {
        const mainMedia = getCurrentMedia();
        const mainStream = mainMedia?.stream;
        if (mainMedia && mainStream) {
            // Workaround for iOS Safari bug
            // https://bugs.webkit.org/show_bug.cgi?id=179363
            const mainMuted = !!mainStream.getTracks().some(t => t.muted);
            const current = mainMedia.audioInput;
            const prev = props.originalMainAudioInput;
            const audioChanged = hasChangedInput(prev, current);
            if (mainMuted || audioChanged) {
                logger.info({
                    mainMuted,
                    audioChanged,
                    currentAudioInput: current,
                    prevAudioInput: prev,
                    mainMedia,
                }, 'Reverting Changes to main');
                try {
                    await replaceMainStream({
                        audio: prev,
                        video: getCurrentMedia()?.videoInput,
                    });
                }
                catch (error) {
                    if (error instanceof Error) {
                        logger.warn({ error }, 'Unable to revert changes to main');
                        return eventHandlers.revertChangesError?.(error);
                    }
                    throw error;
                }
            }
        }
    };
    const updateInput = (hasChanged, updater) => (input) => {
        if (hasChanged(input)) {
            queue.enqueue(async () => {
                await updater(input);
            });
        }
    };
    const toEvenHandler = createEventHandler(eventHandlers);
    return {
        get media() {
            return props.media;
        },
        get audioInputChanged() {
            return hasChangedAudioInput();
        },
        get videoInputChanged() {
            return hasChangedVideoInput();
        },
        get inputChanged() {
            return hasChanges();
        },
        get audioInput() {
            return props.audioInput;
        },
        get videoInput() {
            return props.videoInput;
        },
        get updatingPreview() {
            return props.updatingPreview;
        },
        get updatingMain() {
            return props.updatingMain;
        },
        updateAudioInput: updateInput(input => props.initialized && hasChangedInput(props.audioInput, input), updateAudioInput),
        updateVideoInput: updateInput(input => props.initialized && hasChangedInput(props.videoInput, input), updateVideoInput),
        onMediaChanged: toEvenHandler('media'),
        onAudioInputChanged: toEvenHandler('audioInput'),
        onVideoInputChanged: toEvenHandler('videoInput'),
        onAudioInputError: toEvenHandler('audioInputError'),
        onVideoInputError: toEvenHandler('videoInputError'),
        onApplyChangesError: toEvenHandler('applyChangesError'),
        onRevertChangesError: toEvenHandler('revertChangesError'),
        onUpdatingPreview: toEvenHandler('updatingPreview'),
        onUpdatingMain: toEvenHandler('updatingMain'),
        applyChanges,
        revertChanges,
        cleanup,
    };
};
