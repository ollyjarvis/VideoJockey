import { createSignal } from '@pexip/signal';
const eventTypes = ['open', 'close', 'error', 'message'];
let shouldError = false;
export const setShouldError = (_shouldError) => {
    shouldError = _shouldError;
};
export const serverSignals = eventTypes.reduce((signals, type) => ({
    ...signals,
    [type]: createSignal(),
}), {});
let detachSignals = [];
const detach = () => {
    for (const d of detachSignals) {
        d();
    }
    detachSignals = [];
};
export class FakeWebSocket {
    constructor(url, protocols) {
        this.url = url;
        this.protocols = protocols;
        this.CLOSED = 3;
        this.CLOSING = 2;
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.binaryType = 'blob';
        this.bufferedAmount = 0;
        this.extensions = '';
        this.protocol = '';
        this._closeEmitTimeout = 0;
        this.readyState = FakeWebSocket.CONNECTING;
        this.onopen = null;
        this.onmessage = null;
        this.onerror = null;
        this.onclose = null;
        detach();
        for (const type of eventTypes) {
            let handle = null;
            Object.defineProperty(this, `on${type}`, {
                get: () => {
                    return handle;
                },
                set: (listener) => {
                    if (listener) {
                        detachSignals.push(serverSignals[type].add(e => {
                            if (type === 'close') {
                                this.readyState = 2;
                            }
                            void listener(e);
                        }));
                    }
                    handle = listener;
                    if (serverSignals.open.size > 0 &&
                        serverSignals.error.size > 0 &&
                        serverSignals.close.size > 0) {
                        if (!shouldError) {
                            this.readyState = 1;
                            serverSignals.open.emit(new Event('open'));
                        }
                        else {
                            this.readyState = 2;
                            serverSignals.error.emit(new Event('error'));
                        }
                    }
                },
            });
        }
    }
    addEventListener(_type, _listener) { }
    removeEventListener(_type, _listener) { }
    dispatchEvent(_event) {
        return true;
    }
    close(code = 0, reason = '') {
        this.readyState = 2;
        window.setTimeout(() => {
            this.readyState = 3;
            const closeEvent = new CloseEvent('close', { code, reason });
            Object.defineProperty(closeEvent, 'currentTarget', {
                get: () => this,
            });
            serverSignals.close.emit(closeEvent);
            detach();
        }, this._closeEmitTimeout);
    }
    error() {
        serverSignals.error.emit(new Event('error'));
        detach();
    }
    send(data) {
        serverSignals.message.emit(JSON.parse(data));
    }
    set closeEmitTimeout(emitAfter) {
        this._closeEmitTimeout = emitAfter;
    }
}
FakeWebSocket.CONNECTING = 0;
FakeWebSocket.OPEN = 1;
FakeWebSocket.CLOSING = 2;
FakeWebSocket.CLOSED = 3;
