import type { Segmentation } from './types/media';
interface InternalCanvases {
    drawImageDataCanvas?: OffscreenCanvas;
    maskCanvas?: OffscreenCanvas;
    blurredMaskCanvas?: OffscreenCanvas;
    blurredCanvas?: OffscreenCanvas;
    downScaledCanvas?: OffscreenCanvas;
    backgroundImageCanvas?: OffscreenCanvas;
    inputCanvas?: OffscreenCanvas;
}
export interface Point {
    x: number;
    y: number;
}
export interface Size {
    width: number;
    height: number;
}
export type Rect = Point & Size;
/**
 * Context Attributes
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas/getContext}
 */
interface CanvasRenderingContext2DOptions {
    alpha?: boolean;
}
export declare const getCanvasRenderingContext2D: (canvas: OffscreenCanvas, options?: CanvasRenderingContext2DOptions) => OffscreenCanvasRenderingContext2D;
export declare const flipCanvasHorizontal: (canvas: OffscreenCanvas) => void;
export declare const getImageSize: (image: CanvasImageSource) => Size;
/**
 * Create an OffscreenCanvas with provided width and height. When
 * OffscreenCanvas is not available, a Canvas element is returned.
 *
 * @param width - canvas.width
 * @param height - canvas.height
 */
export declare const createOffscreenCanvas: (width: number, height: number) => OffscreenCanvas;
/**
 * Compare the provided width and height to see if they are the same
 *
 * @param widthA - The width of A
 * @param heightA - The height of A
 * @param widthB - The width of B
 * @param heightB - The height of B
 */
export declare const isEqualSize: (widthA: number, heightA: number, widthB: number, heightB: number) => boolean;
export declare const clearCanvas: (canvas: OffscreenCanvas) => void;
export declare const createCanvasRenderUtils: (processingWidth: number, processingHeight: number) => {
    evaluateInput: (inputImage: CanvasImageSource) => OffscreenCanvas;
    renderImageToCanvas: (image: CanvasImageSource, canvas: OffscreenCanvas, dw?: number, dh?: number, options?: CanvasRenderingContext2DOptions) => void;
    drawBlurEffect: (canvas: OffscreenCanvas, inputImage: CanvasImageSource, segmentations: Segmentation | Segmentation[], foregroundThreshold?: number, backgroundBlurAmount?: number, edgeBlurAmount?: number, flipHorizontal?: boolean) => void;
    drawOverlayEffect: (canvas: OffscreenCanvas, inputImage: CanvasImageSource, backgroundImage: CanvasImageSource | OffscreenCanvas, segmentations: Segmentation | Segmentation[], foregroundThreshold?: number, backgroundBlurAmount?: number, edgeBlurAmount?: number, flipHorizontal?: boolean) => void;
    renderImageToOffScreenCanvas: (image: CanvasImageSource, canvasName: keyof InternalCanvases) => OffscreenCanvas;
    renderImageDataToOffScreenCanvas: (image: ImageData, canvasName: keyof InternalCanvases) => OffscreenCanvas;
    drawAndBlurImageOnOffScreenCanvas: ({ image, blurAmount, offscreenCanvasName, preserveOldDrawing, }: {
        image: CanvasImageSource;
        blurAmount: number;
        offscreenCanvasName: keyof InternalCanvases;
        preserveOldDrawing?: boolean | undefined;
    }) => OffscreenCanvas;
};
export {};
