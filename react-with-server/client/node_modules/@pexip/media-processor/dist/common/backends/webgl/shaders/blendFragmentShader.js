export const blendFragmentShaderSource = `#version 300 es
precision mediump float;

// our textures
uniform sampler2D u_mask;
uniform sampler2D u_mask_prev;
uniform sampler2D u_frame_foreground;
uniform sampler2D u_frame_background;

// control flags
uniform float u_mask_combine_ratio;
uniform float u_foreground_threshold;

in vec2 v_texCoord;

// we need to declare an output for the fragment shader
out vec4 outColor;

// Source: https://github.com/google/mediapipe/blob/8750c3dca1bc00fbe47acf501b7c9c61f3f3bd3f/mediapipe/calculators/image/segmentation_smoothing_calculator.cc#L377
float SmoothingMask(sampler2D prevMask, sampler2D currMask, vec2 uv, float ratio) {
    float prevMaskValue = texture(prevMask, uv).r;
    float newMaskValue = texture(currMask, uv).r;

    /*
    * Assume p := newMaskValue
    * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
    * uncertainty alpha(p) =
    *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
    * uncertainty]
    *
    * The following polynomial approximates uncertainty alpha as a
    * function of (p + 0.5):
    */
    const float c1 = 5.68842;
    const float c2 = -0.748699;
    const float c3 = -57.8051;
    const float c4 = 291.309;
    const float c5 = -624.717;
    float t = newMaskValue - 0.5;
    float x = t * t;

    float uncertainty =
    1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

    float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                            (uncertainty * ratio);
    return outputValue;
}

void main() {
    vec2 halfpixel = 0.5 / vec2(textureSize(u_frame_background, 0));

    vec4 background = texture(u_frame_background, v_texCoord);
    vec4 foreground = texture(u_frame_foreground, v_texCoord);
    float maskAlpha = SmoothingMask(u_mask_prev, u_mask, v_texCoord, u_mask_combine_ratio);
    float filteredMask = maskAlpha;
    if (maskAlpha < u_foreground_threshold) {
        filteredMask = 0.0;
    }

    outColor = mix(background, foreground, filteredMask);
}
`;
