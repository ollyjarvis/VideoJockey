import { assert, clamping } from '../../utils';
import { m3 } from '../../m3';
import { createAndSetupTexture, createGLProgram } from './webglUtils';
import { vertexShaderSource } from './shaders/vertexShader';
import { dualFilterBlurFragmentShaderSource } from './shaders/dualFilterBlurFragmentShader';
const clampBlurAmount = clamping(1, 9);
export const createBlurRenderer = (processor, pass) => {
    const { gl, program, attribLocations, uniformLocations, release } = createGLProgram(processor, {
        attribs: {
            position: 'a_position',
            texCoord: 'a_texCoord',
        },
        uniforms: {
            matrix: 'u_matrix',
            downsampling: 'u_downsampling',
            frame: 'u_frame',
        },
        vertexSrc: vertexShaderSource,
        fragmentSrc: dualFilterBlurFragmentShaderSource,
    });
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    // Position
    const positionBuffer = gl.createBuffer();
    gl.enableVertexAttribArray(attribLocations.position);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(attribLocations.position, 2, gl.FLOAT, false, 0, 0);
    // Put a unit quad in the buffer
    gl.bufferData(gl.ARRAY_BUFFER, 
    // prettier-ignore
    new Float32Array([
        0, 0,
        0, 1,
        1, 0,
        1, 0,
        0, 1,
        1, 1,
    ]), gl.STATIC_DRAW);
    // Texture coordinates for the rectangle
    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, 
    // prettier-ignore
    new Float32Array([
        0, 0,
        0, 1,
        1, 0,
        1, 0,
        0, 1,
        1, 1,
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(attribLocations.texCoord);
    gl.vertexAttribPointer(attribLocations.texCoord, 2, gl.FLOAT, false, 0, 0);
    const setFrameBuffer = (frameBuffer, width, height) => {
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        gl.viewport(0, 0, width, height);
    };
    const createFramebufferAndTexture = (idx) => {
        const texture = createAndSetupTexture(gl);
        assert(texture);
        // Avoid fractional value
        const width = Math.trunc(processor.width / Math.pow(2, idx));
        const height = Math.trunc(processor.height / Math.pow(2, idx));
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        const frameBuffer = gl.createFramebuffer();
        assert(frameBuffer);
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        // Attach a texture to it.
        const attachmentPoint = gl.COLOR_ATTACHMENT0;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, texture, 0);
        return { texture, frameBuffer, width, height };
    };
    const generateBlurBuffers = (pass, offset = 0) => {
        const length = Math.max(clampBlurAmount(offset + pass) - offset, 0);
        return Array.from({
            length,
        }).map((_, currentIdx) => createFramebufferAndTexture(offset + currentIdx));
    };
    // Generate multiple FrameBuffers, textures and the widths and heights are of size
    // of half of the previous one. E.g. 640x480 -> 320x240 -> 160x120 -> 80x60
    const blurBuffers = generateBlurBuffers(pass + 1);
    return {
        render: (frame, pass) => {
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            // Frame texture
            gl.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniformLocations.frame, 0);
            gl.bindTexture(gl.TEXTURE_2D, frame.texture);
            // Dual filter blur
            // Downsampling
            gl.uniform1i(uniformLocations.downsampling, 1);
            // Adjust pass number accordingly
            const currentPass = pass + 1;
            if (currentPass > blurBuffers.length) {
                generateBlurBuffers(currentPass - blurBuffers.length, blurBuffers.length).forEach(buffer => blurBuffers.push(buffer));
            }
            while (currentPass < blurBuffers.length) {
                const buffer = blurBuffers.pop();
                gl.deleteTexture(buffer?.texture ?? null);
                gl.deleteFramebuffer(buffer?.frameBuffer ?? null);
            }
            // Skip the first pass
            for (let i = 1; i < currentPass; i++) {
                const { frameBuffer = null, texture = null, width = processor.width, height = processor.height, } = blurBuffers[i] ?? {};
                // Setup to draw to the frame buffer
                setFrameBuffer(frameBuffer, width, height);
                const matrix = m3.projection(1, 1, 1);
                gl.uniformMatrix3fv(uniformLocations.matrix, false, matrix);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    throw new Error(`downsampling FrameBuffer Status: ${status}`);
                }
                // for the next draw, use the texture we just rendered to.
                gl.bindTexture(gl.TEXTURE_2D, texture);
            }
            // Upsampling
            gl.uniform1i(uniformLocations.downsampling, 0);
            // Skip the first pass
            for (let i = pass - 1; i >= 0; i--) {
                const { frameBuffer = null, texture = null, width = processor.width, height = processor.height, } = blurBuffers[i] ?? {};
                // console.log(`Drawing upsampling pass ${i}, ${width}x${height}`);
                // Setup to draw to the frame buffer
                setFrameBuffer(frameBuffer, width, height);
                const matrix = m3.projection(1, 1, 1);
                gl.uniformMatrix3fv(uniformLocations.matrix, false, matrix);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    throw new Error(`Upsampling FrameBuffer Status: ${status}`);
                }
                // for the next draw, use the texture we just rendered to.
                gl.bindTexture(gl.TEXTURE_2D, texture);
            }
            return {
                texture: blurBuffers[0]?.texture ?? frame.texture,
                width: blurBuffers[0]?.width ?? frame.width,
                height: blurBuffers[0]?.height ?? frame.height,
            };
        },
        release: () => {
            blurBuffers.forEach(({ frameBuffer, texture }) => {
                gl.deleteTexture(texture);
                gl.deleteFramebuffer(frameBuffer);
            });
            gl.deleteBuffer(positionBuffer);
            gl.deleteBuffer(texCoordBuffer);
            gl.deleteVertexArray(vao);
            release();
        },
    };
};
