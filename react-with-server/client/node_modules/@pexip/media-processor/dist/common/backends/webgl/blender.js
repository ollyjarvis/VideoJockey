import { assert } from '../../utils';
import { m3 } from '../../m3';
import { createGLProgram, createAndSetupTexture } from './webglUtils';
import { vertexShaderSource } from './shaders/vertexShader';
import { blendFragmentShaderSource } from './shaders/blendFragmentShader';
export const createBlendRenderer = (processor) => {
    const { gl, program, attribLocations, uniformLocations, release } = createGLProgram(processor, {
        attribs: {
            position: 'a_position',
            texCoord: 'a_texCoord',
        },
        uniforms: {
            matrix: 'u_matrix',
            frameBackground: 'u_frame_background',
            frameForeground: 'u_frame_foreground',
            mask: 'u_mask',
            maskCombineRatio: 'u_mask_combine_ratio',
            foregroundThreshold: 'u_foreground_threshold',
            prevMask: 'u_mask_prev',
        },
        vertexSrc: vertexShaderSource,
        fragmentSrc: blendFragmentShaderSource,
    });
    gl.enable(gl.BLEND);
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    // Position
    const positionBuffer = gl.createBuffer();
    gl.enableVertexAttribArray(attribLocations.position);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(attribLocations.position, 2, gl.FLOAT, false, 0, 0);
    gl.bufferData(gl.ARRAY_BUFFER, 
    // prettier-ignore
    new Float32Array([
        0, 0,
        0, 1,
        1, 0,
        1, 0,
        0, 1,
        1, 1,
    ]), gl.STATIC_DRAW);
    // Texture coordinates for the rectangle
    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, 
    // prettier-ignore
    new Float32Array([
        0, 0,
        0, 1,
        1, 0,
        1, 0,
        0, 1,
        1, 1,
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(attribLocations.texCoord);
    gl.vertexAttribPointer(attribLocations.texCoord, 2, gl.FLOAT, false, 0, 0);
    const outputTexture = createAndSetupTexture(gl);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, processor.width, processor.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
    return {
        render: ({ mask, prevMask, foreground, background, }, options) => {
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.viewport(0, 0, processor.width, processor.height);
            gl.useProgram(program);
            gl.bindVertexArray(vao);
            // Textures
            gl.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniformLocations.frameForeground, 0);
            gl.bindTexture(gl.TEXTURE_2D, foreground.texture);
            gl.activeTexture(gl.TEXTURE1);
            gl.uniform1i(uniformLocations.frameBackground, 1);
            gl.bindTexture(gl.TEXTURE_2D, background.texture);
            gl.activeTexture(gl.TEXTURE2);
            gl.uniform1i(uniformLocations.mask, 2);
            gl.bindTexture(gl.TEXTURE_2D, mask.texture);
            gl.activeTexture(gl.TEXTURE3);
            gl.uniform1i(uniformLocations.prevMask, 3);
            gl.bindTexture(gl.TEXTURE_2D, prevMask?.texture ?? mask.texture);
            // No Flip Y Coordinate for drawing on the frame buffer
            // Project, position and scale to full-size of the canvas
            const matrix = m3.projection(1, 1, 1);
            gl.uniformMatrix3fv(uniformLocations.matrix, false, matrix);
            gl.uniform1f(uniformLocations.maskCombineRatio, options.maskCombineRatio);
            gl.uniform1f(uniformLocations.foregroundThreshold, options.foregroundThreshold);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            assert(outputTexture);
            return {
                texture: outputTexture,
                width: processor.width,
                height: processor.height,
            };
        },
        release: () => {
            gl.deleteBuffer(positionBuffer);
            gl.deleteBuffer(texCoordBuffer);
            gl.deleteTexture(outputTexture);
            gl.deleteFramebuffer(frameBuffer);
            gl.deleteVertexArray(vao);
            release();
        },
    };
};
