/**
 * WebGL Shader type enum
 */
export const GL_SHADER_TYPE = {
    VertexShader: WebGLRenderingContext.VERTEX_SHADER,
    FragmentShader: WebGLRenderingContext.FRAGMENT_SHADER,
};
/**
 * WebGL Shader name enum for error output
 */
export const GL_SHADER_NAME = {
    [GL_SHADER_TYPE.VertexShader]: 'VertexShader',
    [GL_SHADER_TYPE.FragmentShader]: 'FragmentShader',
};
/**
 * Ensure the shader source is WebGL2's shader language aka GLSL ES 3.00
 */
export const isShaderSource = (src) => {
    if (typeof src === 'string') {
        return src.startsWith('#version 300 es');
    }
    return false;
};
/**
 * Ensure the shader source is WebGL2's shader language aka GLSL ES 3.00
 */
export const assertShaderSource = src => {
    if (!isShaderSource(src)) {
        throw new Error('Expecting GLSL ES 3.00 shader source');
    }
};
const errorRE = /ERROR:\s*\d+:(\d+)/gi;
function addLineNumbersWithError(src, log = '', lineOffset = 0) {
    // Note: Error message formats are not defined by any spec so this may or may not work.
    const matches = [...log.matchAll(errorRE)];
    const lineNoToErrorMap = new Map(matches.map((m, ndx) => {
        if (!m[1] || m.index === undefined) {
            return [0, log];
        }
        const lineNo = parseInt(m[1], 10);
        const next = matches[ndx + 1];
        const end = next ? next.index : log.length;
        const msg = log.substring(m.index, end);
        return [lineNo - 1, msg];
    }));
    return src
        .split('\n')
        .map((line, lineNo) => {
        const err = lineNoToErrorMap.get(lineNo);
        return `${lineNo + 1 + lineOffset}: ${line}${err ? `\n\n^^^ ${err}` : ''}`;
    })
        .join('\n');
}
/**
 * Load a shader
 * @param gl - WebGLRenderingContext
 * @param shaderType - The type of shader to load {@link GL_SHADER_TYPE}
 * @param shaderSource - The source of the shader
 */
export const loadShader = (gl, shaderType, shaderSource) => {
    // Create the shader object
    const shader = gl.createShader(shaderType);
    if (!shader) {
        throw new Error(`Unable to create ${GL_SHADER_NAME[shaderType]}`);
    }
    // Load the shader source
    gl.shaderSource(shader, shaderSource);
    // Compile the shader
    gl.compileShader(shader);
    // Check the compile status
    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getShaderParameter#gl.compile_status
    const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!compiled) {
        // Something went wrong during compilation; get the error
        const lastError = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        const message = `Error compiling ${GL_SHADER_NAME[shaderType]}: ${lastError ?? ''}\n${lastError ? addLineNumbersWithError(shaderSource, lastError) : 'no error message available'}`;
        throw new Error(message);
    }
    return shader;
};
/**
 * Create a WebGL program from 2 provided shaders
 * @param gl - WebGLRenderingContext
 * @param shaders - The shader tuple of `[vertexShader, fragmentShader]`
 * @param attribs - An array of attribs names.
 *        Locations will be assigned by index if not passed in.
 * @param locations - The locations for the attribs.
 *        A parallel array to opt_attribs letting you assign locations.
 */
export const createProgram = (gl, shaders, attribs, locations) => {
    const program = gl.createProgram();
    if (!program) {
        throw new Error('Unable to create WebGL program');
    }
    shaders.forEach(function (shader) {
        gl.attachShader(program, shader);
    });
    attribs?.forEach(function (attrib, ndx) {
        const locationIdx = locations?.[ndx] ?? ndx;
        gl.bindAttribLocation(program, locationIdx, attrib);
    });
    gl.linkProgram(program);
    // Check the link status
    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
        // something went wrong with the link
        const lastError = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);
        throw new Error(`Error in program linking: ${lastError ?? ''}\n${shaders
            .map(shader => {
            const src = addLineNumbersWithError(gl.getShaderSource(shader) ?? '');
            const shaderType = gl.getShaderParameter(shader, gl.SHADER_TYPE);
            return `${GL_SHADER_NAME[shaderType]}:\n${src}`;
        })
            .join('\n')}`);
    }
    return [
        program,
        () => {
            shaders.forEach(shader => {
                gl.detachShader(program, shader);
                gl.deleteShader(shader);
            });
            gl.deleteProgram(program);
        },
    ];
};
/**
 * Create a WebGL program from 2 sources
 * @param gl - WebGLRenderingContext
 * @param shaderSources - The shader source tuple of `[vertexShaderSource, fragmentShaderSource]`
 * @param attribs - An array of attribs names.
 *        Locations will be assigned by index if not passed in.
 * @param locations - The locations for the attribs.
 *        A parallel array to opt_attribs letting you assign locations.
 */
export const createProgramFromSources = (gl, [vs, fs], attribs, locations) => createProgram(gl, [
    loadShader(gl, GL_SHADER_TYPE.VertexShader, vs),
    loadShader(gl, GL_SHADER_TYPE.FragmentShader, fs),
], attribs, locations);
export const createAndSetupTexture = (gl) => {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // Set the parameters so we don't need mips and so we're not filtering
    // and we don't repeat at the edges.
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    return texture;
};
export const getLocations = (gl, program, locations) => Object.keys(locations).reduce((acc, key) => {
    const k = key;
    const location = locations[k];
    if (!location) {
        return acc;
    }
    return {
        ...acc,
        [key]: location.startsWith('u_')
            ? gl.getUniformLocation(program, location)
            : gl.getAttribLocation(program, location),
    };
}, {});
export const createGLProgram = (processCanvas, { attribs, uniforms, vertexSrc, fragmentSrc, }) => {
    const gl = processCanvas.getContext('webgl2', {
        premultipliedAlpha: false,
    });
    if (!gl) {
        throw new Error('WebGL2 is not supported');
    }
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    assertShaderSource(vertexSrc);
    assertShaderSource(fragmentSrc);
    const [program, release] = createProgramFromSources(gl, [
        vertexSrc,
        fragmentSrc,
    ]);
    return {
        gl,
        program,
        attribLocations: getLocations(gl, program, attribs),
        uniformLocations: getLocations(gl, program, uniforms),
        release,
    };
};
export const toTextureInfo = (mask) => ({
    texture: mask.getAsWebGLTexture(),
    width: mask.width,
    height: mask.height,
});
/* eslint-enable max-params --- this is utils */
