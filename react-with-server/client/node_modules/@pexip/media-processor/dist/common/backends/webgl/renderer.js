import { PROCESSING_WIDTH, PROCESSING_HEIGHT, EDGE_BLUR_AMOUNT, BACKGROUND_BLUR_AMOUNT, FOREGROUND_THRESHOLD, MASK_COMBINE_RATIO, RENDER_EFFECT, } from '../../constants';
import { createObjectUpdater, createRemoteImageBitmap } from '../../utils';
import { toTextureInfo } from './webglUtils';
import { createTextureRenderer } from './texture';
import { createBlurRenderer } from './blur';
import { createBlendRenderer } from './blender';
import { createCanvasRenderer } from './canvas';
const createLazyProps = (stateBuilder) => {
    const props = {};
    return new Proxy(props, {
        get(target, p, receiver) {
            const prop = target[p];
            if (!prop) {
                target[p] = stateBuilder[p]?.(props);
            }
            return Reflect.get(target, p, receiver);
        },
    });
};
export const createRenderer = (canvas = new OffscreenCanvas(PROCESSING_WIDTH, PROCESSING_HEIGHT), { backgroundBlurAmount = BACKGROUND_BLUR_AMOUNT, backgroundImageUrl = '', edgeBlurAmount = EDGE_BLUR_AMOUNT, effects = RENDER_EFFECT.None, foregroundThreshold = FOREGROUND_THRESHOLD, maskCombineRatio = MASK_COMBINE_RATIO, onError, backgroundImageInits, } = {}) => {
    const rendererCreator = {
        videoFrameRenderer: () => createTextureRenderer(canvas),
        canvasRenderer: () => createCanvasRenderer(canvas),
        backgroundImageRenderer: () => createTextureRenderer(canvas),
        blendRenderer: () => createBlendRenderer(canvas),
        blurRenderer: () => createBlurRenderer(canvas, props.backgroundBlurAmount),
        maskBlurRenderer: () => createBlurRenderer(canvas, props.edgeBlurAmount),
        release: (states) => () => Object.keys(states).forEach(key => key !== 'release' &&
            states[key]?.release()),
    };
    let lazyProps = createLazyProps(rendererCreator);
    const props = {
        backgroundBlurAmount,
        backgroundImageUrl,
        edgeBlurAmount,
        effects,
        foregroundThreshold,
        maskCombineRatio,
        canvas,
        backgroundImages: createRemoteImageBitmap(backgroundImageInits),
        // TODO: refactor to avoid repeated codes
        get videoFrameRenderer() {
            return lazyProps.videoFrameRenderer;
        },
        get canvasRenderer() {
            return lazyProps.canvasRenderer;
        },
        get backgroundImageRenderer() {
            return lazyProps.backgroundImageRenderer;
        },
        get blendRenderer() {
            return lazyProps.blendRenderer;
        },
        get blurRenderer() {
            return lazyProps.blurRenderer;
        },
        // TODO: Impl edge blur
        get maskBlurRenderer() {
            return lazyProps.maskBlurRenderer;
        },
    };
    const updateProps = createObjectUpdater(props);
    const update = options => {
        if (options.backgroundImage) {
            props.backgroundImages.setImage(options.backgroundImage.key, options.backgroundImage.image);
        }
        updateProps(options);
    };
    const handleError = (error) => {
        if (error instanceof Error) {
            return onError?.(error);
        }
        throw error;
    };
    const init = options => {
        if (options) {
            update(options);
        }
    };
    const render = (mask, frame, options) => {
        if (options) {
            updateProps(options);
        }
        const frameTexture = props.videoFrameRenderer.render(frame);
        let background = frameTexture;
        if (props.effects === 'blur' && props.backgroundBlurAmount) {
            background = props.blurRenderer.render(frameTexture, props.backgroundBlurAmount);
        }
        else if (props?.effects === 'overlay' && props.backgroundImageUrl) {
            // Keep rendering with video frame until we get the background image
            const backgroundImage = props.backgroundImages.getImage(props.backgroundImageUrl);
            if (backgroundImage) {
                background = props.backgroundImageRenderer.render({
                    frame: backgroundImage,
                    timestamp: performance.now(),
                    width: backgroundImage.width,
                    height: backgroundImage.height,
                });
            }
            else {
                props.backgroundImages
                    .tryFetchingImage(props.backgroundImageUrl)
                    .catch(error => {
                    handleError(new Error(`FailedToLoadBackgroundImage: ${props.backgroundImageUrl}`, { cause: error }));
                });
            }
        }
        const blendedFrameTexture = props.blendRenderer.render({
            prevMask: props.prevMask && toTextureInfo(props.prevMask),
            mask: toTextureInfo(mask),
            foreground: frameTexture,
            background,
        }, props);
        props.canvasRenderer.render(blendedFrameTexture);
        props.prevMask?.close();
        props.prevMask = mask.clone();
    };
    const release = () => {
        lazyProps.release();
        lazyProps = createLazyProps(rendererCreator);
        props.backgroundImages.clear();
        props.prevMask?.close();
        props.prevMask = undefined;
    };
    return { init, render, release, update };
};
