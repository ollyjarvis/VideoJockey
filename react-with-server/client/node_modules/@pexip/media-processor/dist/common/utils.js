import { SEGMENTATION_MODELS } from './types/segmentation';
export const assert = (t, message = 'AssertError') => {
    if (t === undefined || t === null) {
        throw new Error(message, { cause: t });
    }
    return t;
};
export const isSegmentationModel = (t) => {
    if (typeof t === 'string' &&
        Object.values(SEGMENTATION_MODELS).includes(t)) {
        return true;
    }
    return false;
};
export const createObjectUpdater = (original) => {
    const keys = new Set(Object.keys(original));
    return (another) => {
        for (const key in another) {
            if (keys.has(key) && typeof original[key] === typeof another[key]) {
                original[key] = another[key];
            }
        }
    };
};
export const createRemoteImageBitmap = (map) => {
    const cache = new Map(map);
    const fetchingCache = new Set();
    const fetchImage = async (uri) => {
        const response = await fetch(uri);
        const blob = await response.blob();
        const image = await createImageBitmap(blob);
        return image;
    };
    const tryFetchingImage = async (uri) => {
        const image = cache.get(uri);
        if (!image) {
            if (fetchingCache.has(uri)) {
                return null;
            }
            fetchingCache.add(uri);
            const image = await fetchImage(uri);
            cache.set(uri, image);
            fetchingCache.delete(uri);
            return image;
        }
        return image;
    };
    const removeImage = (uri) => {
        const image = cache.get(uri);
        image?.close();
        return cache.delete(uri);
    };
    return {
        tryFetchingImage,
        setImage: (uri, image) => {
            if (cache.has(uri)) {
                removeImage(uri);
            }
            cache.set(uri, image);
        },
        getImage: (uri) => {
            return cache.get(uri) ?? null;
        },
        removeImage,
        clear: () => {
            cache.forEach(img => img.close());
            cache.clear();
        },
    };
};
export const clamping = (min, max) => (value) => Math.min(Math.max(value, min), max);
export const calculateMaxBlurPass = (height) => Math.trunc(Math.log2(height));
/**
 * Calculate the coordinates and size of the source and destination to fit the
 * target aspect ratio.
 *
 * @param fromWidth - The width of the source
 * @param fromHeight - The height of the source
 * @param toWidth - The width of the destination
 * @param toHeight - The height of the destination
 */
export const resize = (fromWidth, fromHeight, toWidth, toHeight) => {
    if (!fromWidth ||
        !fromHeight ||
        !toWidth ||
        !toHeight ||
        fromWidth * toHeight === toWidth * fromHeight) {
        return {
            sx: 0,
            sy: 0,
            sw: fromWidth,
            sh: fromHeight,
            dx: 0,
            dy: 0,
            dw: toWidth,
            dh: toHeight,
        };
    }
    const originalAspectRatio = fromWidth / fromHeight;
    const targetAspectRatio = toWidth / toHeight;
    if (originalAspectRatio > targetAspectRatio) {
        const sw = Math.ceil(fromWidth * targetAspectRatio) / originalAspectRatio;
        const delta = Math.abs(fromWidth - sw);
        const sx = Math.ceil(delta / 2);
        return {
            sx,
            sy: 0,
            sw,
            sh: fromHeight,
            dx: 0,
            dy: 0,
            dw: toWidth,
            dh: toHeight,
        };
    }
    const sh = Math.ceil(fromHeight * originalAspectRatio) / targetAspectRatio;
    const delta = Math.abs(fromHeight - sh);
    const sy = Math.ceil(delta / 2);
    return {
        sx: 0,
        sy,
        sw: fromWidth,
        sh,
        dx: 0,
        dy: 0,
        dw: toWidth,
        dh: toHeight,
    };
};
