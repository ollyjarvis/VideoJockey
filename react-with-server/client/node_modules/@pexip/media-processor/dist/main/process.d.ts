import type { Queue } from '@pexip/utils';
import type { StatsOptions, AudioSamples, AudioStats, Clock, IsVoice, ThrottleOptions } from './types';
/**
 * Default silent threshold
 * At least one LSB 16-bit data (compare is on absolute value).
 */
export declare const SILENT_THRESHOLD: number;
/**
 * Default mono detection threshold
 * Data must be identical within one LSB 16-bit to be identified as mono.
 */
export declare const MONO_THRESHOLD: number;
/**
 * Default low volume detection threshold
 */
export declare const LOW_VOLUME_THRESHOLD = -60;
/**
 * Default clipping detection threshold
 */
export declare const CLIP_THRESHOLD = 0.98;
/**
 * Default Voice probability threshold
 */
export declare const VOICE_PROBABILITY_THRESHOLD = 0.3;
/**
 * Default clipping count threshold
 * Number of consecutive clipThreshold level samples that indicate clipping.
 */
export declare const CLIP_COUNT_THRESHOLD = 6;
/**
 * AudioStats builder
 *
 * @param stats - overwrite the default attributes
 * @param options - `silentThreshold`, `lowVolumeThreshold` and
 * `clipCountThreshold`
 */
export declare const createAudioStats: (stats?: Partial<AudioStats>, { silentThreshold, lowVolumeThreshold, clipCountThreshold, }?: {
    silentThreshold?: number | undefined;
    lowVolumeThreshold?: number | undefined;
    clipCountThreshold?: number | undefined;
}) => AudioStats;
/**
 * Convert a byte to float, according to web audio spec
 *
 * Floating point audio sample number is defined as: non-interleaved IEEE754
 * 32-bit linear PCM with a nominal range between -1 and +1, that is, 32bits
 * floating point buffer, with each samples between -1.0 and 1.0
 * https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer
 *
 * Byte samples are represented as follows:
 * 128 is silence, 0 is negative max, 256 is positive max
 *
 * @param value - The byte value to convert to float
 *
 * @remarks
 * Ref. https://www.w3.org/TR/webaudio/#dom-analysernode-getbytetimedomaindata
 */
export declare const fromByteToFloat: (value: number) => number;
/**
 * Convert a float to byte, according to web audio spec
 *
 * Floating point audio sample number is defined as: non-interleaved IEEE754
 * 32-bit linear PCM with a nominal range between -1 and +1, that is, 32bits
 * floating point buffer, with each samples between -1.0 and 1.0
 * https://developer.mozilla.org/en-US/docs/Web/API/AudioBuffer
 *
 * Byte samples are represented as follows:
 * 128 is silence, 0 is negative max, 256 is positive max
 *
 * @param value - The float value to convert to byte
 *
 * @remarks
 * Ref. https://www.w3.org/TR/webaudio/#dom-analysernode-getbytetimedomaindata
 */
export declare const fromFloatToByte: (value: number) => number;
/**
 * Copy data from Uint8Array buffer to Float32Array buffer with byte to float conversion
 *
 * @param bytes - The source Byte buffer
 * @param floats - The destination buffer
 */
export declare const copyByteBufferToFloatBuffer: (bytes: Uint8Array, floats: Float32Array) => void;
/**
 * Convert a floating point gain value into a dB representation without any
 * reference, dBFS, https://en.wikipedia.org/wiki/DBFS
 *
 * See https://www.w3.org/TR/webaudio#conversion-to-db
 *
 * @param amplitude - Expected a value in (0, 1]
 */
export declare const toDecibel: (gain: number) => number;
/**
 * Calculate the averaged volume using Root Mean Square, assuming the data is in
 * float form
 *
 * @param data - Audio Frequency data
 *
 * @alpha
 */
export declare const processAverageVolume: (data: number[]) => number;
/**
 * Simple silent detection to only check the first and last bit from the sample
 *
 * @param samples - Audio sample data, this could be in a form of floating number
 * of a byte number as long as the `threshold` value is given accordingly.
 * @param threshold - Silent threshold
 *
 * @defaultValue
 * `1.0 / 32767` assuming the sample is float value
 *
 * @returns
 * `true` when it is silent
 */
export declare const isSilent: (samples: AudioSamples, threshold?: number) => boolean;
/**
 * Check if the provided gain above the low volume threshold, which is
 * considered as low volume.
 *
 * @param gain - Floating point representation of the gain number
 *
 * @returns
 * `true` if the `gain` is lower than the threshold
 */
export declare const isLowVolume: (gain: number, threshold?: number) => boolean;
/**
 * Check if there is clipping
 *
 * @param clipCount - Number of consecutive clip
 *
 * @returns
 * `true` if the `clipCount` is above the threshold, aka clipping
 */
export declare const isClipping: (clipCount: number, threshold?: number) => boolean;
/**
 * Check if provided channels are mono or stereo
 *
 * @param channels - Audio channels and assuming the inputs are in floating
 * point form
 * @param threshold - Mono detection threshold, default to floating point form
 *
 * @defaultValue
 * `1.0 / 32767`
 *
 * @returns
 * `true` if they are mono, otherwise stereo
 */
export declare const isMono: (channels: AudioSamples[], threshold?: number) => boolean;
/**
 * Calculate the audio stats, expected the samples are in float form
 *
 * @param options - See StatsOptions
 *
 * @remarks
 * http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing
 */
export declare const getAudioStats: ({ samples, baseStats, clipThreshold, }: StatsOptions) => AudioStats;
/**
 * VAD options
 */
interface VAOptions {
    /**
     * the RMS threshold used to compare with the input RMS
     */
    volumeThreshold?: number;
    /**
     * The threshold for a voice pulse in terms of time, in millisecond
     */
    VADTimeThreshold?: number;
    /**
     * The clock, can be used for testing
     *
     * @defaultValue
     * `performance`
     */
    clock?: Clock;
}
/**
 * A Naive Voice activity detection
 *
 * @param options - See `VAOptions`
 *
 * @returns `(volume: number) => boolean`, `true` if there is voice
 */
export declare const isVoiceActivity: ({ volumeThreshold, VADTimeThreshold, clock, }?: VAOptions) => (volume: number) => boolean;
/**
 * Compare the provided width and height to see if they are the same
 *
 * @param widthA - The width of A
 * @param heightA - The height of A
 * @param widthB - The width of B
 * @param heightB - The height of B
 */
export declare const isEqualSize: (widthA: number, heightA: number, widthB: number, heightB: number) => boolean;
/**
 * A function to check provided time series data is considered as voice activity
 *
 * @param options - @see VAOptions
 */
export declare const createVoiceDetectorFromTimeData: (options?: VAOptions) => IsVoice<number[]>;
/**
 * A function to check the provided probability is considered as voice activity
 *
 * @param voiceThreshold - A threshold of the probability to be considered as
 * voice activity
 */
export declare const createVoiceDetectorFromProbability: (voiceThreshold?: number) => IsVoice<number>;
/**
 * Create a voice detector based on provided params
 *
 * @param onDetected - When there is voice activity, this callback will be called
 * @param shouldDetect - When return `true`, voice activity will function, otherwise, not function
 * @param options - @see ThrottleOptions
 */
export declare const createVADetector: (onDetected: () => void, shouldDetect: () => boolean, options?: ThrottleOptions) => <T>(isVoice: IsVoice<T>) => (data: T) => void;
/**
 * Create a function to process the AudioStats and check if silent
 * `onSignalDetected` callback is called under 2 situations:
 *
 * ```
 * Logic
 * lastCheck | silent | should call onSignalDetected
 * 0         | 0      | 0
 * 0         | 1      | 1
 * 1         | 0      | 1
 * 1         | 1      | 0
 * ```
 */
export declare const createAudioSignalDetector: (shouldDetect: () => boolean, onDetected: (silent: boolean) => void) => (buffer: Queue<number[]>, threshold?: number) => (samples: number[]) => void;
export {};
