import type { Clock, Callback } from './types';
export declare const hasCreateGain: (context: BaseAudioContext) => boolean;
export declare const hasAudioWorkletNode: () => boolean;
export declare const hasAudioWorklet: () => boolean;
export declare const stopStreamTracks: (stream?: MediaStream) => void | undefined;
/**
 * A function to create `MediaStreamAudioSourceNode` using constructor or factory
 * function depends on the browser supports
 *
 * @param context - @see {@link AudioContext}
 * @param options - @see {@link MediaStreamAudioSourceOptions}
 *
 * @internal
 */
export declare const createMediaStreamAudioSourceNode: (context: AudioContext, options: MediaStreamAudioSourceOptions) => MediaStreamAudioSourceNode;
/**
 * A function to create `MediaStreamAudioSourceNode` using constructor or factory
 * function depends on the browser supports
 *
 * @param context - @see {@link AudioContext}
 * @param options - @see {@link MediaStreamAudioSourceOptions}
 *
 * @internal
 */
export declare const createMediaElementSourceNode: (context: AudioContext, options: MediaElementAudioSourceOptions) => MediaElementAudioSourceNode;
/**
 * A function to create `AnalyserNode` using constructor or factory
 * function depends on the browser supports
 *
 * @param audioContext - @see {@link AudioContext}
 * @param options - @see {@link AnalyserOptions}
 *
 * @internal
 */
export declare const createAnalyserNode: (audioContext: BaseAudioContext, options?: AnalyserOptions) => AnalyserNode;
/**
 * A function to create `GainNode` using constructor or factory
 * function depends on the browser supports
 *
 * @param context - @see {@link AudioContext}
 * @param options - @see {@link GainOptions}
 *
 * @internal
 */
export declare const createGainNode: (context: BaseAudioContext, options?: GainOptions) => GainNode;
/**
 * A function to clone the Audio Track
 *
 * @param stream - Stream to be cloned
 *
 * @internal
 */
export declare const createMediaStreamAudioClone: (stream: MediaStream) => MediaStream;
/**
 * A function to create `MediaStreamAudioDestinationNode` using constructor or
 * factory function depends on the browser supports
 *
 * @param context - @see {@link AudioContext}
 * @param options - @see {@link AudioNodeOptions}
 *
 * @internal
 */
export declare const createMediaStreamAudioDestinationNode: (context: AudioContext, options?: AudioNodeOptions) => MediaStreamAudioDestinationNode;
/**
 * A function to create `DelayNode` using constructor or
 * factory function depends on the browser supports
 *
 * @param context - @see {@link AudioContext}
 * @param options - @see {@link DelayOptions}
 *
 * @internal
 */
export declare const createDelayNode: (context: AudioContext, options?: DelayOptions) => DelayNode;
/**
 * A function to create `ChannelSplitterNode` using constructor or
 * factory function depends on the browser supports
 *
 * @param context - @see {@link AudioContext}
 * @param options - @see {@link ChannelSplitterOptions}
 *
 * @internal
 */
export declare const createChannelSplitterNode: (context: AudioContext, options?: ChannelSplitterOptions) => ChannelSplitterNode;
/**
 * A function to create `ChannelMergerNode` using constructor or
 * factory function depends on the browser supports
 *
 * @param context - @see {@link AudioContext}
 * @param options - @see {@link ChannelSplitterOptions}
 *
 * @internal
 */
export declare const createChannelMergerNode: (context: AudioContext, options?: ChannelMergerOptions) => ChannelMergerNode;
/**
 * Map mute value to gain value
 *
 * ```
 * `true` -> 0
 * `false` -> 1
 * ```
 */
export declare const muteToGain: (mute: boolean) => number;
/**
 * Calculate the timeout based on the provided data and returns a timeout in
 * milliseconds with compensation added
 *
 * @param targetTime - The target timeout after the compensation
 * @param startTime - The start time of the last execution
 * @param endTime - The end time of the last execution
 */
export declare const calculateNextTimeout: (targetTime: number, startTime: number, endTime: number) => number;
type Timeouts = Pick<WindowOrWorkerGlobalScope, 'setTimeout' | 'clearTimeout'>;
/**
 * @param delayInMS - Delay in terms of milliseconds
 * @param params - The parameters to be passed to the provided callback
 */
type DelayCallback<P extends unknown[], R> = (delayInMS: number, ...params: P) => Promise<void | R>;
/**
 * Cancel the delay created by the @see {@link createDelayedCallback}, when it
 * is invoked the ongoing delay will be resolved immediately
 */
type CancelDelay = () => void;
/**
 * Convert a callback to an async callback with delay added
 *
 * @param callback - The callback to be delayed
 * @param options - The options to inject dependences
 *
 * @example
 *
 * ```typescript
 * const getRandom = () => Math.random();
 * const [delayGetRandom, cancelDelayGetRandom] = createDelayedCallback(getRandom);
 *
 * // Delay 500 ms to get the random number
 * const random = await delayGetRandom(500);
 * ```
 */
export declare const createDelayedCallback: <R, P extends unknown[]>(callback: Callback<R, P>, { setTimeout, clearTimeout, }?: Partial<Timeouts>) => [DelayCallback<P, R>, CancelDelay];
type AsyncCallbackLoopOptions = Timeouts & Pick<Performance, 'now'> & {
    frameRate: number;
};
/**
 * Create an async callback loop to be called recursively with delay based on
 * the `frameRate`
 *
 * @param callback - The callback to be invoked
 * @param frameRate - The rate to be expected to invoke the `callback`
 */
export declare const createAsyncCallbackLoop: <P extends unknown[], R extends Promise<unknown>>(callback: Callback<R, P>, frameRate: number, { setTimeout, clearTimeout, now, }?: Partial<AsyncCallbackLoopOptions>) => {
    start: (...params: P) => Promise<void>;
    stop: () => void;
    frameRate: number;
};
export declare const DEFAULT_THROTTLE_MS = 3000;
/**
 * A function to limit the provided callback being called too frequently, and
 * assuming the function is called repeatably, and NOT for general purpose.
 *
 * @param callback - the callback to be called under the specified time
 * @param throttleMs - the specified time for throttling
 * @param clock - how to get the current time
 */
export declare const throttleProcess: <P extends unknown[]>(callback: Callback<void, P>, throttleMs?: number, clock?: Clock) => (...params: P) => void;
type Unsubscribe = () => void;
/**
 * Subscribe visibilitychange event
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event}
 *
 * @param callback - A callback to be called with `document.hidden` when the event is trigger
 */
export declare const subscribeVisibilityChangeEvent: (callback: (hidden: boolean) => Promise<void>) => Unsubscribe;
export {};
