/**
 * We support several ways to get image inputs.
 */
export type InputImage = HTMLVideoElement | HTMLImageElement | HTMLCanvasElement;
import type { Frame, Canvas, CanvasContext, Callback } from '../types';
import { subscribeVisibilityChangeEvent } from '../utils';
import type { ImageType, ProcessInputType, Rect } from '../../common/types/media';
import type { Color } from './types';
/**
 * Draw the source onto the provided canvas according to the destination rect
 *
 * @param canvasContext - A buffer canvas used for drawing the frame
 * @param source - Source to take the frame from
 * @param destination - A destination rect to be draw on the canvas
 */
export declare const drawFrame: (canvasContext: CanvasContext, source: Frame, destination: Rect) => void;
/**
 * Taking a frame from the source and return the `ImageData`
 *
 * @param canvasContext - A buffer canvas used for drawing the frame
 * @param source - Source to take the frame from
 * @param destination - A destination rect to be draw on the canvas for getting the
 * data
 */
export declare const takeFrame: (canvasContext: CanvasContext, source: Frame, destination: Rect) => ImageData;
/**
 * Draw provided ImageData onto a canvas. This is just a wrapper of
 * `putImageData` with both `dx` and `dy` set to 0
 *
 * @param canvasContext - The canvas context to draw on
 * @param data - The data to draw
 */
export declare const drawImageData: (canvasContext: CanvasContext, data: ImageData) => void;
/**
 * Create a Canvas element with provided width and height
 *
 * @param width - canvas.width
 * @param height - canvas.height
 */
export declare const createCanvas: (width: number, height: number) => HTMLCanvasElement;
/**
 * Create an OffscreenCanvas with provided width and height. When
 * OffscreenCanvas is not available, a Canvas element is returned.
 *
 * @param width - canvas.width
 * @param height - canvas.height
 */
export declare const createOffscreenCanvas: (width: number, height: number) => HTMLCanvasElement | OffscreenCanvas;
/**
 * Create a video element with provided width and height, and set it to muted
 *
 * @param width - video.width
 * @param height - video.height
 */
export declare const createVideoElement: (width: number, height: number) => HTMLVideoElement;
export declare const setVideoElementSrc: (video: HTMLVideoElement, src: MediaProvider) => void;
export declare const toVideoElement: (input: MediaStream, width: number, height: number) => HTMLVideoElement;
export declare const playVideo: (video: HTMLVideoElement) => Promise<void>;
/**
 * Load image with provided image element
 */
export declare const loadImage: (image: HTMLImageElement, src: string) => Promise<void>;
export declare const toNumber: (value: number | SVGAnimatedLength) => number;
export declare const getCanvasRenderingContext2D: (canvas: Canvas, options?: CanvasRenderingContext2DSettings) => CanvasRenderingContext2D;
export declare const hasVideoFrameSupport: () => boolean;
export declare const isVideoFrame: (t: unknown) => t is VideoFrame;
export declare const flipCanvasHorizontal: (canvas: Canvas) => void;
export declare const drawStroke: (bytes: Uint8ClampedArray, row: number, column: number, width: number, radius: number, color?: Color) => void;
export declare const isSegmentationBoundary: (data: Uint8ClampedArray, row: number, column: number, width: number, isForegroundId: boolean[], alphaCutoff: number, radius?: number) => boolean;
type Draw = (input: ImageType) => Promise<Canvas>;
export declare const createInputImageConvertor: (draw: Draw) => (input: ProcessInputType) => Promise<InputImage>;
export declare const ensure: <T>(prop: T, message?: string) => NonNullable<T>;
interface FrameCallbackRequestOptions {
    /**
     * Subscribe `visibilitychange` event from the DOM
     * @see {@link subscribeVisibilityChangeEvent}
     */
    subscribeVisibilityChange?: typeof subscribeVisibilityChangeEvent;
}
/**
 * Create a callback loop for video frame processing using
 * `requestVideoFrameCallback` under-the-hood when available otherwise our
 * fallback implementation based on `setTimeout`.
 *
 * @param callback - To be called by the loop
 * @param frameRate - A fallback frame rate when we are not able to get the rate
 * from API
 */
export declare const createFrameCallbackRequest: (callback: Callback<Promise<void>, [ProcessInputType]>, frameRate: number, { subscribeVisibilityChange, }?: FrameCallbackRequestOptions) => {
    start: (input: ProcessInputType) => Promise<void>;
    stop: () => void;
    frameRate: number;
};
export {};
