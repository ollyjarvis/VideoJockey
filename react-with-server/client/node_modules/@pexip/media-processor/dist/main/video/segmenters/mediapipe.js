import { PROCESS_STATUS, PROCESSING_WIDTH, PROCESSING_HEIGHT, } from '../../../common/constants';
const cloneImageRecord = async (image) => {
    const cloned = await createImageBitmap(image.image);
    return { image: cloned, key: image.key };
};
export const createSegmenter = (basePath = '/', { processingWidth = PROCESSING_WIDTH, processingHeight = PROCESSING_HEIGHT, workerScriptUrl = new URL('../../../workers/mediaWorker.js', import.meta.url), credentials = 'same-origin', ...options }) => {
    const props = { status: PROCESS_STATUS.New, modelAsset: options.modelAsset };
    const initWorker = () => {
        const mediaWorker = new Worker(workerScriptUrl, {
            type: 'classic',
            credentials,
        });
        mediaWorker.addEventListener('error', error => {
            throw error.error;
        });
        mediaWorker.addEventListener('message', (event) => {
            const { type } = event.data;
            if (type === 'error') {
                throw event.data.error;
            }
        });
        return mediaWorker;
    };
    async function postMsg(expectedResponseType, message, transfer) {
        if (!expectedResponseType) {
            return props.mediaWorker?.postMessage(message, transfer);
        }
        return await new Promise((resolve, reject) => {
            const handleMessage = (ev) => {
                removeListener();
                switch (ev.data.type) {
                    case expectedResponseType: {
                        // @ts-expect-error --- Call `resolve` is expecting to pass an argument or nothing
                        resolve(ev.data.data);
                        break;
                    }
                    case 'error': {
                        reject(ev.data.error);
                        break;
                    }
                    default: {
                        throw new Error(`UnhandledEvent: ${ev.data.type}`);
                    }
                }
            };
            const handleError = (error) => {
                removeListener();
                reject(error.error);
            };
            const removeListener = () => {
                props.mediaWorker?.removeEventListener('message', handleMessage);
                props.mediaWorker?.removeEventListener('error', handleError);
            };
            props.mediaWorker?.addEventListener('message', handleMessage);
            props.mediaWorker?.addEventListener('error', handleError);
            props.mediaWorker?.postMessage(message, transfer);
        });
    }
    const open = async (processorOptions) => {
        props.status = PROCESS_STATUS.Opening;
        props.mediaWorker = initWorker();
        props.output = processorOptions?.output;
        const backgroundImage = processorOptions?.backgroundImage &&
            (await cloneImageRecord(processorOptions.backgroundImage));
        await postMsg('opened', {
            type: 'open',
            data: {
                basePath,
                processingWidth,
                processingHeight,
                ...processorOptions,
                imageSegmenterOptions: {
                    ...options,
                    ...processorOptions?.imageSegmenterOptions,
                },
                backgroundImage,
            },
        }, [processorOptions?.output, backgroundImage?.image].filter(Boolean));
        props.status = PROCESS_STATUS.Opened;
    };
    const process = async (input, options) => {
        props.status = PROCESS_STATUS.Processing;
        const resultFrame = await postMsg('processed', {
            type: 'process',
            data: { videoFrame: input, renderOptions: options },
        }, [input.frame]);
        if (props.status === PROCESS_STATUS.Processing) {
            props.status = PROCESS_STATUS.Idle;
        }
        return resultFrame;
    };
    const update = async (options) => {
        const backgroundImage = options.backgroundImage &&
            (await cloneImageRecord(options.backgroundImage));
        const transfer = backgroundImage ? [backgroundImage.image] : [];
        await postMsg(undefined, {
            type: 'update',
            data: {
                ...options,
                backgroundImage,
            },
        }, transfer);
    };
    const close = () => {
        props.status = PROCESS_STATUS.Closing;
        void postMsg(undefined, { type: 'close' });
        props.status = PROCESS_STATUS.Closed;
    };
    const destroy = async () => {
        props.status = PROCESS_STATUS.Destroying;
        await postMsg(undefined, { type: 'destroy' });
        props.mediaWorker?.terminate();
        props.mediaWorker = undefined;
        props.status = PROCESS_STATUS.Destroyed;
        return Promise.resolve();
    };
    return {
        get modelAsset() {
            return props.modelAsset;
        },
        set modelAsset(asset) {
            props.modelAsset = asset;
        },
        get status() {
            return props.status;
        },
        get width() {
            return processingWidth;
        },
        get height() {
            return processingHeight;
        },
        open,
        update,
        process,
        close,
        destroy,
    };
};
