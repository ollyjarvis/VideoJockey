import type { ProcessStatus } from '../../common/constants';
import type { ProcessInputType, VideoFrameLike } from '../../common/types/media';
import type { RendererOptions } from '../../common/types/render';
import type { SegmentationModelAsset } from '../../common/types/segmentation';
import type { ProcessorOptions } from '../../common/types/processor';
import type { Transform } from '../types';
export type Color = {
    r: number;
    g: number;
    b: number;
    a: number;
};
export type InputFrame = HTMLCanvasElement | OffscreenCanvas | VideoFrame | ImageBitmap;
interface ProcessingSize {
    /**
     * Processing Width size
     */
    width: number;
    /**
     * Processing height size
     */
    height: number;
}
export interface AsyncAssets {
    tfjsCoreLoaded: boolean;
    tfjsBackendLoaded: boolean;
    glueLoaded: boolean;
}
export interface Process {
    status: ProcessStatus;
    open(): Promise<void>;
    close(): void;
    destroy(): Promise<void>;
}
export interface BackgroundImage {
    key: string;
    image: Blob;
}
export interface Segmenter extends Process, ProcessingSize {
    modelAsset: SegmentationModelAsset;
    backgroundImage?: BackgroundImage;
    open(options?: ProcessorOptions): Promise<void>;
    update(options: ProcessorOptions): Promise<void>;
    process(input: VideoFrameLike, options?: RendererOptions): Promise<VideoFrameLike | undefined>;
}
export interface Detector<T> extends Process {
    detect(input: ProcessInputType): Promise<T>;
}
export interface SegmentationParams extends RendererOptions {
    segmenter: Segmenter;
    width: number;
    height: number;
}
export type SegmentationTransform = Transform<InputFrame, InputFrame> & SegmentationParams & Omit<Process, 'open'>;
export {};
