/**
 * Generic Observer function to handle the emitted signal.
 */
export type Observer<T> = (subject: T) => void | Promise<void>;
/**
 * A detach function to remove its observer from the Signal construct when it is
 * called.
 *
 * @example
 *
 * ```typescript
 * interface Message {
 *   type: string;
 *   payload: any;
 * }
 * const messageSignal = createSignal<Message>();
 *
 * const messageHandler = (message: Message) => {
 *   logger.info({message});
 * };
 *
 * const detachMessageSignal = connectedSignal.add(messageHandler);
 *
 * // Wire the signal to WebSocket onMessage
 * ws.onmessage((message) => {
 *   messageSignal.emit(message);
 * });
 *
 * // Later there is no need to listen the message event, or the context is
 * about to be abandoned
 * // Call the detach function to remove the listener from messageSignal
 * detachMessageSignal();
 *
 * ```
 */
export type Detach = () => void;
/**
 * Signal Interface returned from `createSignal`.
 */
export interface Signal<T> {
    name?: string;
    /**
     * A function to get the current size of observers for internal testing
     * purpose.
     *
     * @internal
     */
    size: number;
    /**
     * Add a new observer to receive the signal
     *
     * @param observer - A function to be called when there is a new signal
     * @param context - Optional context for the observer, you can skip it if
     * observer has already been {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind | bind}
     *
     * @returns function to detach the observer from the signal see {@link DetachFn}
     *
     * @remarks
     * If the `context` is not provided it assumes the `observer` has been
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
     * | `bind`} before it is passed to the signal.
     */
    add(observer: Observer<T>, context?: ThisParameterType<Observer<T>>): Detach;
    /**
     * Add a new observer and got automatically detached immediately after the
     * first signal.
     *
     * @param observer - A function to be called when there is a new signal
     * @param context - Optional context for the observer, you can skip it if
     * observer has already been {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind | bind}
     *
     * @returns function to detach the observer from the signal see {@link DetachFn}
     *
     * @remarks
     * If the `context` is not provided it assumes the `observer` has been
     * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind | `bind`}
     * before it is passed to the signal.
     */
    addOnce(observer: Observer<T>, context?: ThisParameterType<Observer<T>>): Detach;
    /**
     * Remove the `observer` from the signal construct.
     * Please use the returned function from {@link Signal.add} instead
     *
     * @param observer - the `observer` was passed in earlier
     *
     * @internal
     */
    remove(observer: Observer<T>): void;
    /**
     * Emit signal.
     *
     * @remarks
     *
     * It will print a warning when it is trying to emit a signal when there is
     * no observer.
     */
    emit(): void;
    emit(subject: T): void;
}
/**
 * Variant of available signal
 */
export type SignalVariant = 'generic' | 'behavior' | 'replay';
/**
 * Signal options
 *
 * Allow to turn on/off additional features
 *
 * @example
 *
 * ```typescript
 * // Disable the warning message when emitting a signal without any observer
 * const notCriticalSignal = createSignal({
 *   allowEmittingWithoutObserver: true,
 * });
 * ```
 */
export interface SignalOptions {
    /**
     * Set it to `true` to disable the warning when emitting signal without any
     * observers
     *
     * @defaultValue `false`
     */
    allowEmittingWithoutObserver?: boolean;
    /**
     * Use different variant of signal
     *
     * @defaultValue `generic`
     */
    variant?: SignalVariant;
    /**
     * Specify the buffer size for `replay` type signal
     *
     * @defaultValue `2`
     */
    bufferSize?: number;
    /**
     * Giving a name for the ease of debugging
     */
    name?: string;
}
/**
 * Buffer to hold the signal subject
 */
export interface Buffer<T> {
    /**
     * Add value to buffer
     */
    add(value: T): void;
    /**
     * @returns the current buffered values as an array
     */
    entries(): T[];
    /**
     * Iterate over the buffered values
     */
    forEach(cb: (value: T, index: number) => void): void;
}
export type ExtractSignalsState<T extends Array<Signal<unknown>>> = {
    [K in keyof T]: T[K] extends Signal<infer S> ? S | undefined : undefined;
};
