import { logger } from './logger.js';
import { ContentType, HEADER } from './utils.js';
export class BadRequestError extends Error {
    constructor(message) {
        super(message);
        this.name = 'BadRequestError';
    }
}
export class UnauthorizedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'UnauthorizedError';
    }
}
export class ForbiddenError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ForbiddenError';
    }
}
export class NotFoundError extends Error {
    constructor(message) {
        super(message);
        this.name = 'NotFoundError';
    }
}
export class GoneError extends Error {
    constructor(message) {
        super(message);
        this.name = 'GoneError';
    }
}
export class ServiceUnavailableError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ServiceUnavailableError';
    }
}
export class InternalServerError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InternalServerError';
    }
}
export class NotModifiedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'NotModifiedError';
    }
}
export class UnknownError extends Error {
    constructor(message) {
        super(message);
        this.name = 'UnknownError';
    }
}
/**
 * Creates MEE api wrapper for the given `apiAddress` and `token`
 *
 * @privateRemarks  This will be generated from OpenApi schema
 *
 * @returns Api wrapper with all the main CRUD fns
 */
export const createApi = () => {
    const getPath = (apiAddress) => (path) => `${apiAddress}/v1/meetings${path}`;
    const fetcher = async (...args) => {
        const [path, init] = args;
        const printableUrl = typeof path === 'string' ? path : '';
        logger.debug(`Fetching ${printableUrl}`);
        const res = await fetch(path, init);
        const data = (await res.json());
        if ('token' in data && typeof data.token === 'string') {
            logger.redact(data.token);
        }
        if ('participant_secret' in data &&
            typeof data.participant_secret === 'string') {
            logger.redact(data.participant_secret);
        }
        logger.debug({ res, data }, `Data for ${printableUrl}`);
        return { status: res.status, data };
    };
    const token = async ({ abortSignal, apiAddress, token, headers, }) => {
        const { data, status } = await fetcher(`${apiAddress}/oauth/token`, {
            method: 'POST',
            body: new URLSearchParams({
                grant_type: 'client_credentials',
                client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
                client_assertion: token,
            }),
            signal: abortSignal,
            headers: {
                [HEADER.CONTENT_TYPE]: ContentType.FORM_URLENCODED,
                [HEADER.ACCEPT]: ContentType.JSON,
                ...headers,
            },
        });
        switch (status) {
            case 200:
                return { data, status };
            case 400:
                throw new BadRequestError(data.reason);
            case 500:
                throw new InternalServerError(data.reason);
            default:
                throw new UnknownError('');
        }
    };
    const create = async ({ abortSignal, apiAddress, accessToken, headers, }) => {
        const { data, status } = await fetcher(getPath(apiAddress)(''), {
            method: 'POST',
            body: JSON.stringify({}),
            signal: abortSignal,
            headers: {
                [HEADER.CONTENT_TYPE]: ContentType.JSON,
                ...(accessToken && { [HEADER.AUTHORIZATION]: accessToken }),
                ...headers,
            },
        });
        switch (status) {
            case 200:
                return { data, status };
            case 400:
                throw new BadRequestError(data.reason);
            case 401:
                throw new UnauthorizedError(data.reason);
            case 403:
                throw new ForbiddenError(data.reason);
            case 404:
                throw new NotFoundError(data.reason);
            case 500:
                throw new InternalServerError(data.reason);
            default:
                throw new UnknownError('');
        }
    };
    const participants = async ({ abortSignal, meetingId, apiAddress, accessToken, headers, }) => {
        const { data, status } = await fetcher(getPath(apiAddress)(`/${meetingId}/participants`), {
            method: 'POST',
            body: JSON.stringify({}),
            signal: abortSignal,
            headers: {
                [HEADER.CONTENT_TYPE]: ContentType.JSON,
                ...(accessToken && { [HEADER.AUTHORIZATION]: accessToken }),
                ...headers,
            },
        });
        switch (status) {
            case 200:
                return { data, status };
            case 400:
                throw new BadRequestError(data.reason);
            case 401:
                throw new UnauthorizedError(data.reason);
            case 403:
                throw new ForbiddenError(data.reason);
            case 404:
                throw new NotFoundError(data.reason);
            case 500:
                throw new InternalServerError(data.reason);
            default:
                throw new UnknownError('');
        }
    };
    const join = async ({ abortSignal, apiAddress, meetingId, participantId, participantSecret, headers, }) => {
        const { data, status } = await fetcher(getPath(apiAddress)(`/${meetingId}/join`), {
            method: 'POST',
            body: JSON.stringify({
                participant_id: participantId,
                participant_secret: participantSecret,
            }),
            signal: abortSignal,
            headers: {
                [HEADER.CONTENT_TYPE]: ContentType.JSON,
                ...headers,
            },
        });
        switch (status) {
            case 200:
                return { data, status };
            case 400:
                throw new BadRequestError(data.reason);
            case 404:
                throw new NotFoundError(data.reason);
            case 410:
                throw new GoneError(data.reason);
            case 500:
                throw new InternalServerError(data.reason);
            case 503:
                throw new ServiceUnavailableError(data.reason);
            default:
                throw new UnknownError('');
        }
    };
    const terminate = async ({ abortSignal, apiAddress, meetingId, accessToken, headers, }) => {
        const { data, status } = await fetcher(getPath(apiAddress)(`/${meetingId}`), {
            method: 'DELETE',
            signal: abortSignal,
            headers: {
                ...(accessToken && { [HEADER.AUTHORIZATION]: accessToken }),
                ...headers,
            },
        });
        switch (status) {
            case 200:
                return { data, status };
            case 304:
                throw new NotFoundError('');
            case 401:
                throw new UnauthorizedError(data.reason);
            case 403:
                throw new ForbiddenError(data.reason);
            case 404:
                throw new NotFoundError(data.reason);
            default:
                throw new UnknownError('');
        }
    };
    return {
        token,
        create,
        join,
        participants,
        terminate,
    };
};
const ACCESS_EXP_BUFFER = 60000;
export const withToken = (createAndSignJWT, apiAddress) => (api) => {
    let token;
    let tokenReceivedDate;
    const isTokenValid = () => Boolean(tokenReceivedDate &&
        token?.expires_in &&
        tokenReceivedDate +
            token.expires_in * 1000 -
            ACCESS_EXP_BUFFER >
            Date.now());
    const getAccessToken = () => `${token?.token_type} ${token?.access_token}`;
    const getToken = async () => {
        if (isTokenValid()) {
            return getAccessToken();
        }
        const res = await api.token({
            token: createAndSignJWT(),
            apiAddress,
        });
        token = res.data;
        tokenReceivedDate = Date.now();
        return getAccessToken();
    };
    return {
        create: async ({ headers } = {}) => api.create({
            accessToken: await getToken(),
            apiAddress,
            ...(headers && { headers }),
        }),
        participants: async ({ meetingId, headers, }) => api.participants({
            meetingId,
            accessToken: await getToken(),
            apiAddress,
            ...(headers && { headers }),
        }),
    };
};
