import fs from 'fs/promises';
import path from 'path';

import {optimize} from './svgo.mjs';
import {Content} from './content.mjs';

async function generateSvg(icon) {
    if (!icon) {
        return;
    }
    const svg = new Content(
        '<!-- FILE GENERATED BY packages/components/design-tokens/build-scripts/generate-icons.js DO NOT CHANGE -->',
    );
    const {data} = await optimize(icon.graphic, {
        path: icon.pascalName,
    });
    svg.push(data);
    await fs.writeFile(
        path.resolve('..', 'generated', 'icons', `${icon.iconName}.svg`),
        await svg.print('html'),
    );
    const declaration = new Content(
        '// FILE GENERATED BY packages/components/design-tokens/build-scripts/generate-icons.js DO NOT CHANGE',
    );
    declaration.push(
        'import type React from "react";',
        `const icon: React.FC<React.ComponentProps<'svg'>>;`,
        'export default icon;',
    );
    await fs.writeFile(
        path.resolve('..', 'generated', 'icons', `${icon.iconName}.svg.d.ts`),
        await declaration.print('typescript'),
    );
}

async function generate(meta) {
    const collection = meta.reduce((all, icon) => {
        const [key, size] = icon.pascalName.split('_');
        return key in all
            ? {...all, [key]: {...all[key], [`size${size}`]: icon}}
            : {...all, [key]: {[`size${size}`]: icon}};
    }, {});
    const sortedCollection = Object.entries(collection).sort((a, b) =>
        a[0].localeCompare(b[0]),
    );

    const iconImports = new Content(
        '// FILE GENERATED BY packages/components/design-tokens/build-scripts/generate-icons.js DO NOT CHANGE',
    );
    iconImports.push(0, '');
    iconImports.push(
        1,
        'export interface IconSource {',
        "   size16: React.FC<React.ComponentProps<'svg'>>;",
        "   size24: React.FC<React.ComponentProps<'svg'>>;",
        "   size32: React.FC<React.ComponentProps<'svg'>>;",
        '}',
        '',
        'export interface IconCollection {',
    );
    iconImports.push(2, 'const collection: IconCollection = {');

    for (const [name, icon] of sortedCollection) {
        const tiny = icon.size16;
        const small = icon.size24;
        const medium = icon.size32;
        if (tiny) {
            await generateSvg(tiny);
            iconImports.push(
                0,
                `import ${tiny.pascalName} from './icons/${tiny.iconName}.svg';`,
            );
        }
        if (small) {
            await generateSvg(small);
            iconImports.push(
                0,
                `import ${small.pascalName} from './icons/${small.iconName}.svg';`,
            );
        }
        if (medium) {
            await generateSvg(medium);
            iconImports.push(
                0,
                `import ${medium.pascalName} from './icons/${medium.iconName}.svg';`,
            );
        }
        iconImports.push(1, `   ${name}: IconSource;`);
        iconImports.push(
            2,
            `${name}: {size16: ${
                tiny?.pascalName ?? small?.pascalName ?? medium?.pascalName
            }, size24: ${
                small?.pascalName ?? medium?.pascalName ?? tiny?.pascalName
            }, size32: ${
                medium?.pascalName ?? small?.pascalName ?? tiny?.pascalName
            }},`,
        );
    }

    iconImports.push(1, '}');
    iconImports.push(2, '};', '', 'export default collection;');

    await fs.writeFile(
        path.resolve('..', 'generated', 'Icons.ts'),
        await iconImports.print('typescript'),
    );
}

async function gatherMeta() {
    const metaFiles = (
        await fs.readdir(path.resolve('..', 'generated', 'icons'))
    ).filter(name => name.endsWith('json'));

    const meta = await Promise.all(
        metaFiles.map(async file =>
            JSON.parse(
                await fs.readFile(
                    path.resolve('..', 'generated', 'icons', file),
                ),
            ),
        ),
    );

    return meta;
}

export function generateIcons() {
    return gatherMeta()
        .then(generate)
        .catch(reason => console.log(reason));
}
