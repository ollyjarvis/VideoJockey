import fs from 'fs';
import path from 'path';
import {camelCase, paramCase, pascalCase} from 'change-case';

import {fetchWithAccessToken} from './fetchWithAccessToken.mjs';
import {FRAME_ID} from './constants.mjs';
import {Content} from './content.mjs';

const getFrameChildren = parent => {
    let children = [];
    parent.children.forEach(child => {
        children.push(child);
        if (child.children) {
            children = [...children, ...getFrameChildren(child)];
        }
    });
    return children;
};

export async function getFonts(recourceIds) {
    const {
        nodes: {[recourceIds]: fontsFrame},
    } = await fetchWithAccessToken(
        `files/${FRAME_ID}/nodes?ids=${recourceIds}`,
    );
    return getFrameChildren(fontsFrame.document)
        .filter(x => !!x.styles)
        .map(t => ({
            ...t,
            styles: fontsFrame.styles[t.styles.text],
        }))
        .reduce((acc, curr) => {
            if (/semibold/i.test(curr.style.fontPostScriptName)) {
                curr.style.fontWeight = 600;
                if (/bold/i.test(curr.styles.name)) {
                    curr.styles.name = 'body-bold';
                }
            }
            acc[paramCase(curr.styles.name)] = {
                fontName: camelCase(curr.styles.name),
                fontSize: curr.style.fontSize,
                lineHeight: curr.style.lineHeightPercentFontSize,
                fontWeight: curr.style.fontWeight,
            };
            return acc;
        }, {});
}

function pxToRem(bodySizePx, relativeSizeInPx) {
    const relativeSize = Number(relativeSizeInPx);
    if (isNaN(relativeSize)) {
        throw Error('Cannot get relative size, returned NaN.');
    }
    const remSize = parseFloat(relativeSize) / bodySizePx;
    return Math.round(remSize * 100) / 100;
}

function stripFontVariantKey(key) {
    return key.replace(/(mobile-|desktop-)/, '');
}

export function syncFonts(fonts, destination, suffix) {
    const content = new Content(
        '/* FILE GENERATED BY packages/components/design-tokens/build-scripts/fonts.js DO NOT CHANGE */',
    );

    const fontsObject = Object.entries(fonts);
    const bodySize = fontsObject.find(property => {
        const variant = stripFontVariantKey(property[0]);
        return variant === 'body';
    })[1].fontSize;

    content.push(
        ['$base-size', suffix].filter(s => !!s).join('-') + `: ${bodySize}px;`,
    );

    content.push(0, ['$font-size', suffix].filter(s => !!s).join('-') + ': (');
    content.push(
        1,
        ['$font-line-height', suffix].filter(s => !!s).join('-') + ': (',
    );
    content.push(
        2,
        ['$font-weight', suffix].filter(s => !!s).join('-') + ': (',
    );

    for (const [key, {fontSize, lineHeight, fontWeight}] of fontsObject) {
        const strippedKey = stripFontVariantKey(key);
        content.push(0, `${strippedKey}: ${pxToRem(bodySize, fontSize)}rem,`);
        content.push(1, `${strippedKey}: ${lineHeight}%,`);
        content.push(2, `${strippedKey}: ${fontWeight},`);
    }
    for (let i = 0; i <= 2; i++) {
        content.push(i, ');');
    }
    fs.writeFileSync(
        path.resolve('..', 'generated', destination),
        content.print('scss'),
    );
    syncConstants(fonts);
}

function syncConstants(fonts) {
    console.log(fonts);

    const content = new Content(
        '// FILE GENERATED BY packages/components/design-tokens/build-scripts/fonts.js DO NOT CHANGE',
    );

    content.push('export enum FontVariant {');
    for (const {fontName} of Object.values(fonts)) {
        const strippedFontName = fontName.replace(/(mobile|desktop)/, '');
        content.push(
            `${pascalCase(strippedFontName)} = '${camelCase(
                strippedFontName,
            )}',`,
        );
    }
    content.push('}');

    fs.writeFileSync(
        path.resolve('..', 'generated', 'constants.ts'),
        content.print('typescript'),
    );
}
