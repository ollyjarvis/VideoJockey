import fs from 'fs';
import path from 'path';
import {pascalCase} from 'change-case';

import {fetchWithAccessToken} from './fetchWithAccessToken.mjs';
import {ICONS_FRAME_ID, RESOURCES_IDS} from './constants.mjs';

function normalizeIconName(frameName, iconDetails) {
    // iconDetails = " Size=24px, Direction=right, Styling=primary "
    const details = iconDetails
        .trim()
        .split(',')
        .map(detail => detail.replace(/.+\=/g, ''));
    // size = "24px"
    const size = details.slice(0, 1).join();
    // modifier = "right-primary"
    const modifier = details.slice(1).join('-');
    const iconName = frameName
        .replace(/Icons/, 'icon')
        .replace(/\//g, '-')
        .toLowerCase();
    return `${size}-${iconName}${modifier ? `-${modifier}` : ''}`;
}

function newIconName(name) {
    const figmaName = name.split('-');
    // Push the first part of the name to the back.
    figmaName.push(figmaName.shift());
    return figmaName.join('-').replace('px', '');
}

function saveIconResource(icon) {
    console.log(
        `fetching resource and storing meta: ${JSON.stringify(icon, null, 2)}`,
    );
    fetchWithAccessToken(icon.resource, 'text')
        .then(graphic =>
            fs.promises.writeFile(
                path.resolve(
                    '..',
                    'generated',
                    'icons',
                    `${icon.iconName}.json`,
                ),
                JSON.stringify({...icon, graphic}, null, 2),
            ),
        )
        .then(() => console.log(`wrote ${icon.iconName}.json`))
        .catch(reason => console.log(reason));
}

function fetchResource(vector) {
    return fetchWithAccessToken(
        `images/${ICONS_FRAME_ID}/?ids=${vector.id}&format=svg`,
    )
        .then(icon => {
            const name = normalizeIconName(vector.parentFrameName, vector.name);
            const iconName = newIconName(name);
            saveIconResource({
                iconName,
                name,
                pascalName: `Icon${pascalCase(iconName)}`,
                resource: icon.images[vector.id],
            });
        })
        .catch(reason => console.log(reason));
}

export async function downloadIcons() {
    const {
        nodes: {[RESOURCES_IDS.ICONS]: iconsFrame},
    } = await fetchWithAccessToken(
        `files/${ICONS_FRAME_ID}/nodes?ids=${RESOURCES_IDS.ICONS}`,
    );

    const frames = iconsFrame.document.children;

    // frames now contain multiple nested icons
    const allIcons = frames.reduce(
        (icons, currentFrame) => [
            ...icons,
            ...currentFrame.children.map(child => ({
                ...child,
                parentFrameName: currentFrame.name,
            })),
        ],
        [],
    );

    console.log(
        `preparing to fetch ${allIcons.length} icons from ${frames.length} frames`,
    );

    await allIcons
        // needs to be sequential, else we get http 429 from figma
        .reduce(
            (promise, vector) =>
                promise.then(async icons => [
                    ...icons,
                    await fetchResource(vector),
                ]),
            Promise.resolve([]),
        );
}
