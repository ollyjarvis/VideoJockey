import {
  Backoff,
  createSignal,
  v4_default
} from "./chunk-EUEAMH6E.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/sdp-transform/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/sdp-transform/lib/grammar.js"(exports, module) {
    var grammar = module.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{ name: "name" }],
      i: [{ name: "description" }],
      u: [{ name: "uri" }],
      e: [{ name: "email" }],
      p: [{ name: "phone" }],
      z: [{ name: "timezones" }],
      // TODO: this one can actually be parsed properly...
      r: [{ name: "repeats" }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o) {
            return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o) {
            return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o) {
            return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o) {
            return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o) {
            return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: "msid",
          reg: /^msid:(.*)/,
          format: "msid:%s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o.tcptype != null ? " tcptype %s" : "%v";
            if (o.generation != null) {
              str += " generation %d";
            }
            str += o["network-id"] != null ? " network-id %d" : "%v";
            str += o["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o) {
            var str = "ssrc:%d";
            if (o.attribute != null) {
              str += " %s";
              if (o.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o) {
            return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o) {
            return o.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o) {
            return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o) {
            return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o) {
            return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o) {
            var str = "mediaclk:";
            str += o.id != null ? "id=%s %s" : "%v%s";
            str += o.mediaClockValue != null ? "=%s" : "";
            str += o.rateNumerator != null ? " rate=%s" : "";
            str += o.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar).forEach(function(key) {
      var objs = grammar[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
  }
});

// node_modules/sdp-transform/lib/parser.js
var require_parser = __commonJS({
  "node_modules/sdp-transform/lib/parser.js"(exports) {
    var toIntIfInt = function(v) {
      return String(Number(v)) === v ? Number(v) : v;
    };
    var attachProperties = function(match, location, names, rawName) {
      if (rawName && !names) {
        location[rawName] = toIntIfInt(match[1]);
      } else {
        for (var i = 0; i < names.length; i += 1) {
          if (match[i + 1] != null) {
            location[names[i]] = toIntIfInt(match[i + 1]);
          }
        }
      }
    };
    var parseReg = function(obj, location, content) {
      var needsBlank = obj.name && obj.names;
      if (obj.push && !location[obj.push]) {
        location[obj.push] = [];
      } else if (needsBlank && !location[obj.name]) {
        location[obj.name] = {};
      }
      var keyLocation = obj.push ? {} : (
        // blank object that will be pushed
        needsBlank ? location[obj.name] : location
      );
      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
      if (obj.push) {
        location[obj.push].push(keyLocation);
      }
    };
    var grammar = require_grammar();
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    exports.parse = function(sdp) {
      var session = {}, media = [], location = session;
      sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
        var type = l[0];
        var content = l.slice(2);
        if (type === "m") {
          media.push({ rtp: [], fmtp: [] });
          location = media[media.length - 1];
        }
        for (var j = 0; j < (grammar[type] || []).length; j += 1) {
          var obj = grammar[type][j];
          if (obj.reg.test(content)) {
            return parseReg(obj, location, content);
          }
        }
      });
      session.media = media;
      return session;
    };
    var paramReducer = function(acc, expr) {
      var s = expr.split(/=(.+)/, 2);
      if (s.length === 2) {
        acc[s[0]] = toIntIfInt(s[1]);
      } else if (s.length === 1 && expr.length > 1) {
        acc[s[0]] = void 0;
      }
      return acc;
    };
    exports.parseParams = function(str) {
      return str.split(/;\s?/).reduce(paramReducer, {});
    };
    exports.parseFmtpConfig = exports.parseParams;
    exports.parsePayloads = function(str) {
      return str.toString().split(" ").map(Number);
    };
    exports.parseRemoteCandidates = function(str) {
      var candidates = [];
      var parts = str.split(" ").map(toIntIfInt);
      for (var i = 0; i < parts.length; i += 3) {
        candidates.push({
          component: parts[i],
          ip: parts[i + 1],
          port: parts[i + 2]
        });
      }
      return candidates;
    };
    exports.parseImageAttributes = function(str) {
      return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
      });
    };
    exports.parseSimulcastStreamList = function(str) {
      return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
          var scid, paused = false;
          if (format[0] !== "~") {
            scid = toIntIfInt(format);
          } else {
            scid = toIntIfInt(format.substring(1, format.length));
            paused = true;
          }
          return {
            scid,
            paused
          };
        });
      });
    };
  }
});

// node_modules/sdp-transform/lib/writer.js
var require_writer = __commonJS({
  "node_modules/sdp-transform/lib/writer.js"(exports, module) {
    var grammar = require_grammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x) {
        if (i >= len) {
          return x;
        }
        var arg = args[i];
        i += 1;
        switch (x) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i = 0; i < obj.names.length; i += 1) {
          var n = obj.names[i];
          if (obj.name) {
            args.push(location[obj.name][n]);
          } else {
            args.push(location[obj.names[i]]);
          }
        }
      } else {
        args.push(location[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = [
      "v",
      "o",
      "s",
      "i",
      "u",
      "e",
      "p",
      "c",
      "b",
      "t",
      "r",
      "z",
      "a"
    ];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    module.exports = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp = [];
      outerOrder.forEach(function(type) {
        grammar[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el) {
              sdp.push(makeLine(type, obj, el));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp.push(makeLine("m", grammar.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el) {
                sdp.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp.join("\r\n") + "\r\n";
    };
  }
});

// node_modules/sdp-transform/lib/index.js
var require_lib = __commonJS({
  "node_modules/sdp-transform/lib/index.js"(exports) {
    var parser = require_parser();
    var writer = require_writer();
    exports.write = writer;
    exports.parse = parser.parse;
    exports.parseParams = parser.parseParams;
    exports.parseFmtpConfig = parser.parseFmtpConfig;
    exports.parsePayloads = parser.parsePayloads;
    exports.parseRemoteCandidates = parser.parseRemoteCandidates;
    exports.parseImageAttributes = parser.parseImageAttributes;
    exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
  }
});

// node_modules/@pexip/socket-manager/dist/utils.js
var isWebSocketClosedWithError = (errorCode) => errorCode > 1e3 && errorCode < 1017;
var isOpen = (readyState) => readyState === WebSocket.OPEN;
var isClosed = (readyState) => readyState === WebSocket.CLOSED;
var isConnecting = (readyState) => readyState === WebSocket.CONNECTING;
var createSocketSignal = (name, scope = "", variant = "generic") => createSignal({
  name: `socket-manager/${scope ? `${scope}/` : ""}${name}`,
  allowEmittingWithoutObserver: allowEmittingWithoutObserver(name),
  variant
});
var allowEmittingWithoutObserver = (signal) => [
  "onConnecting",
  "onConnected",
  "onReconnecting",
  "onReconnected",
  "onDisconnected",
  "onError",
  "onMessage"
].includes(signal);
var REQUIRED_SOCKET_SIGNAL_KEYS = [
  "onConnecting",
  "onConnected",
  "onReconnecting",
  "onReconnected",
  "onDisconnected",
  "onError",
  "onMessage"
];
var createSocketSignals = (scope = "") => {
  return REQUIRED_SOCKET_SIGNAL_KEYS.reduce((signals, key) => ({
    ...signals,
    [key]: createSocketSignal(key, scope)
  }), {});
};

// node_modules/@pexip/socket-manager/dist/types.js
var SocketCloseEventCode;
(function(SocketCloseEventCode2) {
  SocketCloseEventCode2[SocketCloseEventCode2["NormalClosure"] = 1e3] = "NormalClosure";
  SocketCloseEventCode2[SocketCloseEventCode2["GoingAway"] = 1001] = "GoingAway";
  SocketCloseEventCode2[SocketCloseEventCode2["AbnormalClosure"] = 1006] = "AbnormalClosure";
  SocketCloseEventCode2[SocketCloseEventCode2["Reconnect"] = 4e3] = "Reconnect";
  SocketCloseEventCode2[SocketCloseEventCode2["Finalize"] = 4999] = "Finalize";
})(SocketCloseEventCode || (SocketCloseEventCode = {}));

// node_modules/@pexip/socket-manager/dist/constants.js
var MAX_RECONNECT_ATTEMPTS = 8;
var BACKOFF_BASE_SETTINGS = { min: 100, max: 3e4, jitter: 0.2 };

// node_modules/@pexip/socket-manager/dist/baseLogger.js
var LogLevels;
(function(LogLevels5) {
  LogLevels5[LogLevels5["trace"] = 10] = "trace";
  LogLevels5[LogLevels5["debug"] = 20] = "debug";
  LogLevels5[LogLevels5["info"] = 30] = "info";
  LogLevels5[LogLevels5["warn"] = 40] = "warn";
  LogLevels5[LogLevels5["error"] = 50] = "error";
  LogLevels5[LogLevels5["fatal"] = 60] = "fatal";
  LogLevels5[LogLevels5["silent"] = Number.MAX_SAFE_INTEGER] = "silent";
})(LogLevels || (LogLevels = {}));
function createConsoleLogger() {
  return Object.freeze({
    /* eslint-disable no-console -- set logger to console */
    fatal: (meta, message) => console.error(message, meta),
    error: (meta, message) => console.error(message, meta),
    warn: (meta, message) => console.warn(message, meta),
    info: (meta, message) => console.info(message, meta),
    debug: (meta, message) => console.debug(message, meta),
    trace() {
    },
    // Noop
    silent() {
    },
    // Noop
    redact() {
    }
    // Noop
    /* eslint-enable no-console -- set logger to console */
  });
}

// node_modules/@pexip/socket-manager/dist/logger.js
var logger = createConsoleLogger();

// node_modules/@pexip/socket-manager/dist/socketManager.js
var createSocketManager = (signals, maxReconnectAttempts = MAX_RECONNECT_ATTEMPTS) => {
  let ws;
  let reconnectTimmer;
  let reconnectAttempt = 0;
  const _connect = (url, protocols, backoff = new Backoff(BACKOFF_BASE_SETTINGS)) => {
    clearTimeout(reconnectTimmer);
    if (isOpen(ws == null ? void 0 : ws.readyState)) {
      logger.warn("Connection already established.");
      return;
    }
    ws = new window.WebSocket(url, protocols);
    window.pexDebug = { ...window.pexDebug, ws };
    if (reconnectAttempt === 0) {
      signals.onConnecting.emit();
    } else {
      signals.onReconnecting.emit();
    }
    ws.onopen = (event) => {
      logger.info({ event }, "Connection opened");
      if (reconnectAttempt === 0) {
        signals.onConnected.emit();
      } else {
        signals.onReconnected.emit();
        reconnectAttempt = 0;
        backoff.reset();
      }
    };
    ws.onmessage = (msg) => {
      try {
        const event = JSON.parse(msg.data);
        if ("token" in event && typeof event.token === "string") {
          logger.redact(event.token);
        }
        logger[event.type === "error" ? "error" : "debug"]({ event }, `Message received with type ${event.type}`);
        signals.onMessage.emit(event);
      } catch (error) {
        logger.error({ error }, "Parsing message failed");
      }
    };
    ws.onerror = (error) => {
      logger.error({ error }, "Connection error");
      signals.onError.emit();
    };
    ws.onclose = (event) => {
      if (isWebSocketClosedWithError(event.code) && reconnectAttempt < maxReconnectAttempts) {
        logger.error({ event }, "Connection closed with error, reconnecting");
        reconnectAttempt += 1;
        reconnectTimmer = window.setTimeout(() => {
          _connect(url, protocols, backoff);
        }, backoff.duration());
      } else {
        logger.error({ event }, "Connection closed");
        signals.onDisconnected.emit(event);
      }
    };
  };
  const connect = async ({ abortController, url }) => {
    return new Promise((resolve, reject) => {
      var _a;
      if ((_a = abortController == null ? void 0 : abortController.signal) == null ? void 0 : _a.aborted) {
        return reject(abortController == null ? void 0 : abortController.signal.reason);
      }
      const handleAbort = () => {
        if (isConnecting(ws == null ? void 0 : ws.readyState)) {
          disconnect(SocketCloseEventCode.NormalClosure);
        }
        reject(abortController == null ? void 0 : abortController.signal.reason);
      };
      abortController == null ? void 0 : abortController.signal.addEventListener("abort", handleAbort, {
        once: true
      });
      const withAbortController = (fn) => (args) => {
        abortController == null ? void 0 : abortController.signal.removeEventListener("abort", handleAbort);
        fn(args);
      };
      signals.onConnected.addOnce(withAbortController(resolve));
      signals.onError.addOnce(withAbortController(reject));
      _connect(url);
    });
  };
  const disconnect = (code, reason) => {
    ws == null ? void 0 : ws.close(code, reason);
  };
  const send = (data) => {
    if (!data.id) {
      data.id = v4_default();
    }
    if ("token" in data && typeof data.token === "string") {
      logger.redact(data.token);
    }
    if (isClosed(ws == null ? void 0 : ws.readyState)) {
      logger.warn({ data }, "Websocket closed. Ignoring sending data");
      return;
    }
    ws == null ? void 0 : ws.send(JSON.stringify(data));
    logger.debug({ data }, `Message sent with type ${data.type}`);
    return data.id;
  };
  return {
    connect,
    disconnect,
    send,
    get readyState() {
      return ws == null ? void 0 : ws.readyState;
    },
    get bufferedAmount() {
      return ws == null ? void 0 : ws.bufferedAmount;
    }
  };
};

// node_modules/@pexip/vpaas-api/dist/baseLogger.js
var LogLevels2;
(function(LogLevels5) {
  LogLevels5[LogLevels5["trace"] = 10] = "trace";
  LogLevels5[LogLevels5["debug"] = 20] = "debug";
  LogLevels5[LogLevels5["info"] = 30] = "info";
  LogLevels5[LogLevels5["warn"] = 40] = "warn";
  LogLevels5[LogLevels5["error"] = 50] = "error";
  LogLevels5[LogLevels5["fatal"] = 60] = "fatal";
  LogLevels5[LogLevels5["silent"] = Number.MAX_SAFE_INTEGER] = "silent";
})(LogLevels2 || (LogLevels2 = {}));
function createConsoleLogger2() {
  return Object.freeze({
    /* eslint-disable no-console -- set logger to console */
    fatal: (meta, message) => console.error(message, meta),
    error: (meta, message) => console.error(message, meta),
    warn: (meta, message) => console.warn(message, meta),
    info: (meta, message) => console.info(message, meta),
    debug: (meta, message) => console.debug(message, meta),
    trace() {
    },
    // Noop
    silent() {
    },
    // Noop
    redact() {
    }
    // Noop
    /* eslint-enable no-console -- set logger to console */
  });
}

// node_modules/@pexip/vpaas-api/dist/logger.js
var logger2 = createConsoleLogger2();

// node_modules/@pexip/vpaas-api/dist/utils.js
var ContentType;
(function(ContentType2) {
  ContentType2["JSON"] = "application/json";
  ContentType2["FORM_URLENCODED"] = "application/x-www-form-urlencoded";
})(ContentType || (ContentType = {}));
var HEADER;
(function(HEADER2) {
  HEADER2["ACCEPT"] = "Accept";
  HEADER2["CONTENT_TYPE"] = "Content-Type";
  HEADER2["AUTHORIZATION"] = "Authorization";
})(HEADER || (HEADER = {}));

// node_modules/@pexip/vpaas-api/dist/api.js
var BadRequestError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "BadRequestError";
  }
};
var UnauthorizedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "UnauthorizedError";
  }
};
var ForbiddenError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ForbiddenError";
  }
};
var NotFoundError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "NotFoundError";
  }
};
var GoneError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "GoneError";
  }
};
var ServiceUnavailableError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ServiceUnavailableError";
  }
};
var InternalServerError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InternalServerError";
  }
};
var UnknownError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "UnknownError";
  }
};
var createApi = () => {
  const getPath = (apiAddress) => (path) => `${apiAddress}/v1/meetings${path}`;
  const fetcher = async (...args) => {
    const [path, init] = args;
    const printableUrl = typeof path === "string" ? path : "";
    logger2.debug(`Fetching ${printableUrl}`);
    const res = await fetch(path, init);
    const data = await res.json();
    if ("token" in data && typeof data.token === "string") {
      logger2.redact(data.token);
    }
    if ("participant_secret" in data && typeof data.participant_secret === "string") {
      logger2.redact(data.participant_secret);
    }
    logger2.debug({ res, data }, `Data for ${printableUrl}`);
    return { status: res.status, data };
  };
  const token = async ({ abortSignal, apiAddress, token: token2, headers }) => {
    const { data, status } = await fetcher(`${apiAddress}/oauth/token`, {
      method: "POST",
      body: new URLSearchParams({
        grant_type: "client_credentials",
        client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
        client_assertion: token2
      }),
      signal: abortSignal,
      headers: {
        [HEADER.CONTENT_TYPE]: ContentType.FORM_URLENCODED,
        [HEADER.ACCEPT]: ContentType.JSON,
        ...headers
      }
    });
    switch (status) {
      case 200:
        return { data, status };
      case 400:
        throw new BadRequestError(data.reason);
      case 500:
        throw new InternalServerError(data.reason);
      default:
        throw new UnknownError("");
    }
  };
  const create = async ({ abortSignal, apiAddress, accessToken, headers }) => {
    const { data, status } = await fetcher(getPath(apiAddress)(""), {
      method: "POST",
      body: JSON.stringify({}),
      signal: abortSignal,
      headers: {
        [HEADER.CONTENT_TYPE]: ContentType.JSON,
        ...accessToken && { [HEADER.AUTHORIZATION]: accessToken },
        ...headers
      }
    });
    switch (status) {
      case 200:
        return { data, status };
      case 400:
        throw new BadRequestError(data.reason);
      case 401:
        throw new UnauthorizedError(data.reason);
      case 403:
        throw new ForbiddenError(data.reason);
      case 404:
        throw new NotFoundError(data.reason);
      case 500:
        throw new InternalServerError(data.reason);
      default:
        throw new UnknownError("");
    }
  };
  const participants = async ({ abortSignal, meetingId, apiAddress, accessToken, headers }) => {
    const { data, status } = await fetcher(getPath(apiAddress)(`/${meetingId}/participants`), {
      method: "POST",
      body: JSON.stringify({}),
      signal: abortSignal,
      headers: {
        [HEADER.CONTENT_TYPE]: ContentType.JSON,
        ...accessToken && { [HEADER.AUTHORIZATION]: accessToken },
        ...headers
      }
    });
    switch (status) {
      case 200:
        return { data, status };
      case 400:
        throw new BadRequestError(data.reason);
      case 401:
        throw new UnauthorizedError(data.reason);
      case 403:
        throw new ForbiddenError(data.reason);
      case 404:
        throw new NotFoundError(data.reason);
      case 500:
        throw new InternalServerError(data.reason);
      default:
        throw new UnknownError("");
    }
  };
  const join = async ({ abortSignal, apiAddress, meetingId, participantId, participantSecret, headers }) => {
    const { data, status } = await fetcher(getPath(apiAddress)(`/${meetingId}/join`), {
      method: "POST",
      body: JSON.stringify({
        participant_id: participantId,
        participant_secret: participantSecret
      }),
      signal: abortSignal,
      headers: {
        [HEADER.CONTENT_TYPE]: ContentType.JSON,
        ...headers
      }
    });
    switch (status) {
      case 200:
        return { data, status };
      case 400:
        throw new BadRequestError(data.reason);
      case 404:
        throw new NotFoundError(data.reason);
      case 410:
        throw new GoneError(data.reason);
      case 500:
        throw new InternalServerError(data.reason);
      case 503:
        throw new ServiceUnavailableError(data.reason);
      default:
        throw new UnknownError("");
    }
  };
  const terminate = async ({ abortSignal, apiAddress, meetingId, accessToken, headers }) => {
    const { data, status } = await fetcher(getPath(apiAddress)(`/${meetingId}`), {
      method: "DELETE",
      signal: abortSignal,
      headers: {
        ...accessToken && { [HEADER.AUTHORIZATION]: accessToken },
        ...headers
      }
    });
    switch (status) {
      case 200:
        return { data, status };
      case 304:
        throw new NotFoundError("");
      case 401:
        throw new UnauthorizedError(data.reason);
      case 403:
        throw new ForbiddenError(data.reason);
      case 404:
        throw new NotFoundError(data.reason);
      default:
        throw new UnknownError("");
    }
  };
  return {
    token,
    create,
    join,
    participants,
    terminate
  };
};

// node_modules/@pexip/peer-connection/dist/types.js
var RecoveryTimeout;
(function(RecoveryTimeout2) {
  RecoveryTimeout2[RecoveryTimeout2["ConnectionState"] = 5e3] = "ConnectionState";
  RecoveryTimeout2[RecoveryTimeout2["IceConnectionState"] = 2e3] = "IceConnectionState";
  RecoveryTimeout2[RecoveryTimeout2["Negotiation"] = 200] = "Negotiation";
})(RecoveryTimeout || (RecoveryTimeout = {}));

// node_modules/@pexip/peer-connection/dist/baseLogger.js
var LogLevels3;
(function(LogLevels5) {
  LogLevels5[LogLevels5["trace"] = 10] = "trace";
  LogLevels5[LogLevels5["debug"] = 20] = "debug";
  LogLevels5[LogLevels5["info"] = 30] = "info";
  LogLevels5[LogLevels5["warn"] = 40] = "warn";
  LogLevels5[LogLevels5["error"] = 50] = "error";
  LogLevels5[LogLevels5["fatal"] = 60] = "fatal";
  LogLevels5[LogLevels5["silent"] = Number.MAX_SAFE_INTEGER] = "silent";
})(LogLevels3 || (LogLevels3 = {}));
function createConsoleLogger3() {
  return Object.freeze({
    /* eslint-disable no-console -- set logger to console */
    fatal: (meta, message) => console.error(message, meta),
    error: (meta, message) => console.error(message, meta),
    warn: (meta, message) => console.warn(message, meta),
    info: (meta, message) => console.info(message, meta),
    debug: (meta, message) => console.debug(message, meta),
    trace() {
    },
    // Noop
    silent() {
    },
    // Noop
    redact() {
    }
    // Noop
    /* eslint-enable no-console -- set logger to console */
  });
}

// node_modules/@pexip/peer-connection/dist/logger.js
var logger3 = createConsoleLogger3();

// node_modules/@pexip/peer-connection/dist/constants.js
var CAN_SET_STREAMS = typeof RTCRtpSender !== "undefined" && "setStreams" in RTCRtpSender.prototype;

// node_modules/@pexip/peer-connection/dist/utils.js
var createRefsLog = (getRefs) => {
  const info = (obj) => {
    const refs = getRefs();
    return { ...refs, ...obj };
  };
  return {
    debug: (msg, obj) => logger3.debug(info(obj), msg),
    info: (msg, obj) => logger3.info(info(obj), msg),
    error: (msg, obj) => logger3.error(info(obj), msg),
    warn: (msg, obj) => logger3.warn(info(obj), msg)
  };
};
var getPeerConnectionStates = (pc) => ({
  get connectionState() {
    return pc.connectionState;
  },
  get iceConnectionState() {
    return pc.iceConnectionState;
  },
  get iceGatheringState() {
    return pc.iceGatheringState;
  },
  get signalingState() {
    return pc.signalingState;
  }
});
var getStatesAndProps = (pc) => {
  return {
    ...getPeerConnectionStates(pc),
    offerOptions: pc.offerOptions,
    answerOptions: pc.answerOptions
  };
};
var logReferences = (refs) => ({
  module: refs.module,
  references: refs
});
var createGetRefs = (pc) => () => ({
  ...logReferences(pc.references),
  ...getStatesAndProps(pc)
});
var jsonifyIceErrorEvent = (event) => {
  if ("RTCPeerConnectionIceErrorEvent" in window && event instanceof RTCPeerConnectionIceErrorEvent) {
    return Object.defineProperty(event, "toJSON", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: () => ({
        address: event.address,
        url: event.url,
        port: event.port,
        errorCode: event.errorCode,
        errorText: event.errorText
      })
    });
  }
  return event;
};
var wirePeerConnectionEventHandler = ({ key, pc, signal }) => {
  const log = createRefsLog(createGetRefs(pc));
  switch (key) {
    case "onConnectionStateChange":
      pc.onConnectionStateChange = (event) => {
        log.info("onConnectionStateChange emitted", {
          event
        });
        signal.emit(pc.connectionState);
      };
      break;
    case "onDataChannel":
      pc.onDataChannel = (event) => {
        log.info("onDataChannel emitted", {
          event
        });
        signal.emit(event.channel);
      };
      break;
    case "onIceCandidate":
      pc.onIceCandidate = (event) => {
        log.info("onIceCandidate emitted", {
          event
        });
        signal.emit(event.candidate);
      };
      break;
    case "onIceCandidateError":
      pc.onIceCandidateError = (event) => {
        log.info("onIceCandidateError emitted", {
          event: jsonifyIceErrorEvent(event)
        });
        signal.emit(event);
      };
      break;
    case "onIceConnectionStateChange":
      pc.onIceConnectionStateChange = (event) => {
        log.info("onIceConnectionStateChange emitted", {
          event
        });
        signal.emit(pc.iceConnectionState);
      };
      break;
    case "onIceGatheringStateChange":
      pc.onIceGatheringStateChange = (event) => {
        log.info("onIceGatheringStateChange emitted", {
          event
        });
        signal.emit(pc.iceGatheringState);
      };
      break;
    case "onNegotiationNeeded":
      pc.onNegotiationNeeded = () => {
        log.info("onNegotiationNeeded emitted");
        signal.emit();
      };
      break;
    case "onSignalingStateChange":
      pc.onSignalingStateChange = (event) => {
        log.info("onSignalingStateChange emitted", {
          event
        });
        signal.emit(pc.signalingState);
      };
      break;
    case "onTrack":
      pc.onTrack = (event) => {
        log.info("onTrack emitted", {
          event
        });
        signal.emit(event);
      };
      break;
    case "onRemoteStreams":
      pc.onRemoteStreams = (config) => {
        log.info("onRemoteStreams emitted", {
          config
        });
        signal.emit(config);
      };
      break;
    case "onTransceiverChange":
      pc.onTransceiverChange = () => {
        log.info("onTransceiverChanged");
        signal.emit();
      };
      break;
    case "onSecureCheckCode":
      pc.onSecureCheckCode = (secureCheckCode) => {
        log.info("onSecureCheckCode emitted", { secureCheckCode });
        signal.emit(secureCheckCode);
      };
      break;
  }
};
var wirePeerConnectionEvents = (pc, signals) => {
  Object.keys(signals).forEach((eventKey) => {
    const signalKey = eventKey;
    const signal = signals[signalKey];
    if (signal) {
      wirePeerConnectionEventHandler({
        key: signalKey,
        pc,
        signal
      });
    }
  });
};
var createPCSignal = (name, crucial = true) => createSignal({
  name: `call:peerConnection:${name}`,
  allowEmittingWithoutObserver: !crucial
});
var REQUIRED_SIGNAL_KEYS = [
  "onOfferRequired",
  "onReceiveAnswer",
  "onReceiveOffer",
  "onOffer",
  "onOfferIgnored",
  "onAnswer",
  "onError"
];
var createPCSignals = (more, scope = "") => {
  const signalScope = scope && [scope, ":"].join("");
  return [...REQUIRED_SIGNAL_KEYS, ...more].reduce((signals, key) => ({
    ...signals,
    [key]: createPCSignal(`${signalScope}${key}`)
  }), {});
};
var withSignals = (peer) => (
  /**
   * Map signals
   *
   * @param signals - The provided signals to map to the PC events
   */
  ({ onReceiveAnswer, onReceiveIceCandidate, onReceiveOffer, onOffer, onOfferIgnored, onAnswer, onError, onNegotiationNeeded = createPCSignal("onNegotiationNeeded"), onIceCandidateError = createPCSignal("onIceCandidateError"), ...pcEventSignals }) => {
    pcEventSignals && wirePeerConnectionEvents(peer, {
      ...pcEventSignals,
      onNegotiationNeeded,
      onIceCandidateError
    });
    const props = {
      receivingFirstOffer: true,
      makingOffer: false,
      ignoreOffer: false
    };
    const log = createRefsLog(() => ({
      ...createGetRefs(peer)(),
      ...props
    }));
    const emitError = (msg, context) => {
      log.error(msg, { ...context, ...getPeerConnectionStates(peer) });
      if ((context == null ? void 0 : context.error) instanceof Error) {
        onError.emit(context.error);
      }
    };
    const emitLocalDescription = (sdp) => {
      const localDescription = sdp ?? peer.pendingLocalDescription;
      switch (localDescription == null ? void 0 : localDescription.type) {
        case "offer":
          onOffer.emit(localDescription);
          break;
        case "answer":
          onAnswer.emit(localDescription);
          break;
        default:
          log.error('Attempt to emit localDescription other than "answer" and "offer"', { localDescription });
          throw new Error("Unknown SDP type");
      }
      peer.releaseLocalICECandidatesBuffer(false);
    };
    const signalSubscriptions = [
      onNegotiationNeeded.add(async () => {
        log.info("handle onNegotiationNeeded signal");
        try {
          props.makingOffer = true;
          const offer = await peer.createOffer();
          log.info("emit offer", { offer });
          emitLocalDescription(offer);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message !== "Ignore") {
              emitError("createOffer", { error });
            }
          }
        } finally {
          props.makingOffer = false;
        }
      }),
      onIceCandidateError.add((error) => {
        emitError("onIceCandidateError", {
          event: error
        });
      }),
      onReceiveIceCandidate == null ? void 0 : onReceiveIceCandidate.add(async (candidate) => {
        log.info("handle onReceiveIceCandidate signal", { candidate });
        try {
          await peer.receiveIceCandidate(candidate);
        } catch (error) {
          if (!props.ignoreOffer) {
            emitError("receiveIceCandidate", { error, candidate });
          }
        }
      }),
      onReceiveOffer.add(async (offer) => {
        try {
          const offerCollisionDetected = props.makingOffer || peer.signalingState !== "stable";
          props.ignoreOffer = !peer.polite && offerCollisionDetected;
          log.info("handle receiveOffer signal", {
            politePeer: peer.polite,
            offer,
            offerCollisionDetected,
            ignoreOffer: props.ignoreOffer
          });
          if (props.ignoreOffer) {
            log.info("ignore offer", {
              politePeer: peer.polite,
              offer,
              offerCollisionDetected,
              ignoreOffer: props.ignoreOffer
            });
            onOfferIgnored.emit();
            return;
          }
          peer.releaseLocalICECandidatesBuffer(true);
          await peer.receiveOffer(offer);
          const answer = await peer.createAnswer();
          log.info("emit answer", { answer });
          emitLocalDescription(answer);
        } catch (error) {
          emitError("receiveOffer/createAnswer", { error, offer });
        } finally {
          props.receivingFirstOffer = false;
        }
      }),
      onReceiveAnswer.add(async (answer) => {
        log.info("handle receiveAnswer signal", { answer });
        props.receivingFirstOffer = false;
        try {
          await peer.receiveAnswer(answer);
        } catch (error) {
          emitError("receiveAnswer", { error, answer });
        }
      })
    ].flatMap((a) => a ? [a] : []);
    return signalSubscriptions;
  }
);
var isTransceiverMediaType = (mediaType) => mediaType === "audio" || mediaType === "video";
var assertTransceiverMediaType = (mediaType) => {
  if (!isTransceiverMediaType(mediaType)) {
    throw new Error(`Expected a media kind string, "audio" | "video" but got "${mediaType}"`);
  }
  return mediaType;
};
var resolveKindOrTrack = (kindOrTrack) => {
  if (!("MediaStreamTrack" in window) || !(kindOrTrack instanceof MediaStreamTrack)) {
    return {
      kind: assertTransceiverMediaType(kindOrTrack),
      track: void 0
    };
  }
  return {
    track: kindOrTrack,
    kind: assertTransceiverMediaType(kindOrTrack.kind)
  };
};
var isMediaStream = (t) => {
  if (typeof t === "object" && t !== null && t instanceof MediaStream) {
    return true;
  }
  return false;
};
var isMediaStreams = (t) => Array.isArray(t) && t.every(isMediaStream);
var isDataChannelObsolete = (dataChannel) => dataChannel.readyState === "closing" || dataChannel.readyState === "closed";
var createDataChannelConfig = (init) => {
  const props = {
    ...init
  };
  const subscribeEvents = (dc) => {
    var _a;
    (_a = init.eventListeners) == null ? void 0 : _a.forEach(({ event, listener, options }) => {
      switch (event) {
        case "message":
          dc.addEventListener(event, listener, options);
          break;
        default:
          dc.addEventListener(event, listener, options);
          break;
      }
    });
    dc.addEventListener("close", () => {
      var _a2;
      (_a2 = init.eventListeners) == null ? void 0 : _a2.forEach(({ event, listener, options }) => {
        switch (event) {
          case "message":
            dc.removeEventListener(event, listener, options);
            break;
          default:
            dc.removeEventListener(event, listener, options);
            break;
        }
      });
    }, { once: true });
  };
  const isDirty = () => !props.dataChannel || isDataChannelObsolete(props.dataChannel);
  return {
    get dirty() {
      return isDirty();
    },
    get options() {
      return init;
    },
    get kind() {
      return "application";
    },
    get dataChannel() {
      return props.dataChannel;
    },
    set dataChannel(dc) {
      if (dc) {
        subscribeEvents(dc);
      }
      props.dataChannel = dc;
    },
    syncDataChannel: (peer) => {
      if (!isDirty()) {
        return;
      }
      logger3.debug({ init, props }, "syncDataChannel");
      const dc = peer.createDataChannel(init.label, init);
      props.dataChannel = dc;
      subscribeEvents(dc);
    },
    toString() {
      return [
        this.options.label,
        `DataChannel${this.options.id !== void 0 ? `(${this.options.id})` : ""}`
      ].join("-");
    }
  };
};
var isTransceiverObsolete = (transceiver) => {
  return transceiver.mid === null && transceiver.currentDirection !== null;
};
var compareRecord = (record1, record2) => {
  if (record1 === record2) {
    return true;
  }
  if (!record1 || !record2) {
    return false;
  }
  const keys = /* @__PURE__ */ new Set([...Object.keys(record1), ...Object.keys(record2)]);
  for (const key of keys) {
    if (record1[key] !== record2[key]) {
      return false;
    }
  }
  return true;
};
var compareArray = (list1, list2, predicate) => {
  if (list1 === void 0 && list2 !== void 0 || list1 !== void 0 && list2 === void 0) {
    return false;
  }
  const len = Math.max((list1 == null ? void 0 : list1.length) ?? 0, (list2 == null ? void 0 : list2.length) ?? 0);
  for (let i = 0; i < len; i++) {
    const a = list1 == null ? void 0 : list1[i];
    const b = list2 == null ? void 0 : list2[i];
    if (!predicate(a, b)) {
      return false;
    }
  }
  return true;
};
var merge = (oldParam, newParam) => {
  const len = Math.max(oldParam.length, newParam.length);
  const merged = [];
  for (let i = 0; i < len; i++) {
    const o = oldParam[i];
    const n = newParam[i];
    if (!n) {
      return merged;
    }
    merged.push({ ...o, ...n });
  }
  return merged;
};
var createTransceiverConfig = ({ kindOrTrack, content, direction, streams, sendEncodings, transceiver, allowAutoChangeOfDirection = true, relativeDirection = true }, onTransceiverChanged) => {
  const { track, kind } = resolveKindOrTrack(kindOrTrack);
  const props = {
    content: content ?? "main",
    track,
    kind,
    streams: streams ?? [],
    direction: direction ?? "sendrecv",
    transceiver,
    allowAutoChangeOfDirection,
    relativeDirection,
    sendEncodings
  };
  const dirty = {
    track: transceiver ? false : Boolean(track),
    streams: transceiver ? false : Boolean(streams == null ? void 0 : streams.length),
    sendParameters: transceiver ? false : Boolean(sendEncodings),
    direction: allowAutoChangeOfDirection,
    get dirty() {
      return this.track || this.streams || this.direction || this.sendParameters;
    }
  };
  const proxy = new Proxy(props, {
    // eslint-disable-next-line max-params --- from lib.dom.d
    set(target, p, newValue, receiver) {
      var _a, _b;
      switch (p) {
        case "track": {
          if (newValue !== void 0 && target[p] !== newValue) {
            Reflect.set(target, p, newValue, receiver);
            dirty[p] = true;
          }
          return true;
        }
        case "streams": {
          if (newValue !== void 0 && isMediaStreams(newValue)) {
            const setOld = new Set(target[p].map((s) => s.id));
            const setNew = new Set(newValue.map((s) => s.id));
            for (const old of setOld) {
              if (setNew.has(old)) {
                return true;
              }
            }
            target[p] = newValue;
            dirty[p] = true;
          }
          return true;
        }
        case "direction": {
          const newDirection = deriveSendDirectionFromTrack(newValue, ((_a = props.transceiver) == null ? void 0 : _a.sender.track) ?? props.track);
          if (target[p] !== newDirection) {
            Reflect.set(target, p, newDirection, receiver);
            dirty[p] = true;
          }
          return true;
        }
        case "transceiver": {
          if (newValue !== void 0 && newValue instanceof RTCRtpTransceiver && target[p] !== newValue) {
            (_b = target[p]) == null ? void 0 : _b.stop();
            if (target.track) {
              dirty.track = true;
            }
            if (target.streams.length) {
              dirty.streams = true;
            }
            if (target.direction !== newValue.direction) {
              dirty.direction = true;
            }
            Reflect.set(target, p, newValue, receiver);
            onTransceiverChanged(newValue, config);
          }
          return true;
        }
        case "sendEncodings": {
          if (newValue !== void 0 && !compareArray(target[p], newValue, compareRecord)) {
            Reflect.set(target, p, newValue, receiver);
            dirty.sendParameters = true;
          }
          return true;
        }
        default: {
          Reflect.set(target, p, newValue, receiver);
          return true;
        }
      }
    }
  });
  const syncStreams = () => {
    if (!CAN_SET_STREAMS || !dirty.streams || !props.track || !props.transceiver || isTransceiverObsolete(props.transceiver)) {
      return;
    }
    dirty.streams = false;
    logger3.debug({ config, props, dirty }, "syncStreams");
    props.transceiver.sender.setStreams(...props.streams);
  };
  const syncDirection = () => {
    if (!props.allowAutoChangeOfDirection || !dirty.direction || !props.transceiver || isTransceiverObsolete(props.transceiver)) {
      return;
    }
    if (props.transceiver.direction === props.direction) {
      return;
    }
    dirty.direction = false;
    logger3.debug({ config, props, dirty }, "syncDirection");
    props.transceiver.direction = props.direction;
  };
  const syncSenderTrack = async () => {
    var _a;
    if (!props.transceiver || isTransceiverObsolete(props.transceiver) || !dirty.track || props.track === void 0 || props.track === ((_a = props.transceiver) == null ? void 0 : _a.sender.track)) {
      return;
    }
    dirty.track = false;
    logger3.debug({ config, props, dirty }, "syncSenderTrack");
    await props.transceiver.sender.replaceTrack(props.track);
    syncStreams();
  };
  const syncSenderParameters = async () => {
    var _a;
    const encodings = props.sendEncodings;
    const params = (_a = props.transceiver) == null ? void 0 : _a.sender.getParameters();
    if (params && !params.encodings) {
      params.encodings = [{}];
    }
    if (!props.transceiver || isTransceiverObsolete(props.transceiver) || !dirty.sendParameters || encodings === void 0 || params === void 0 || params.encodings.every((param, idx) => compareRecord(param, encodings[idx]))) {
      return;
    }
    dirty.sendParameters = false;
    logger3.debug({ config, props, dirty }, "syncSenderTrack");
    await props.transceiver.sender.setParameters({
      ...params,
      encodings: merge(params.encodings, encodings)
    });
  };
  const isDirty = () => dirty.dirty || !props.transceiver || isTransceiverObsolete(props.transceiver);
  const config = {
    get content() {
      return props.content;
    },
    get dirty() {
      return isDirty();
    },
    get kind() {
      return props.kind;
    },
    get allowAutoChangeOfDirection() {
      return props.allowAutoChangeOfDirection;
    },
    set allowAutoChangeOfDirection(allowed) {
      props.allowAutoChangeOfDirection = allowed;
    },
    get relativeDirection() {
      return props.relativeDirection;
    },
    set relativeDirection(relative) {
      props.relativeDirection = relative;
    },
    get direction() {
      return props.direction;
    },
    set direction(direction2) {
      proxy.direction = direction2;
    },
    get sendEncodings() {
      return props.sendEncodings;
    },
    set sendEncodings(encodings) {
      proxy.sendEncodings = encodings;
    },
    get streams() {
      return props.streams;
    },
    set streams(streams2) {
      proxy.streams = streams2;
    },
    get remoteStreams() {
      return props.remoteStreams;
    },
    set remoteStreams(streams2) {
      props.remoteStreams = streams2;
    },
    get transceiver() {
      return props.transceiver;
    },
    set transceiver(transceiver2) {
      proxy.transceiver = transceiver2;
    },
    get track() {
      return props.track;
    },
    set track(track2) {
      proxy.track = track2;
    },
    syncStreams,
    syncDirection,
    syncSenderTrack,
    syncSenderParameters,
    syncTransceiver: async (peer, option = {}) => {
      if (option.track !== void 0) {
        proxy.track = option.track;
      }
      if (option.streams) {
        proxy.streams = option.streams;
      }
      if (option.direction) {
        proxy.direction = option.direction;
      }
      if (option.sendEncodings) {
        proxy.sendEncodings = option.sendEncodings;
      }
      if (!isDirty()) {
        return;
      }
      if (props.transceiver && !isTransceiverObsolete(props.transceiver)) {
        await syncSenderTrack();
        syncDirection();
        await syncSenderParameters();
      } else {
        logger3.debug({ config, props, dirty }, "addTransceiver");
        dirty.track = false;
        dirty.streams = false;
        dirty.direction = false;
        proxy.transceiver = peer.addTransceiver(props.track ?? props.kind, {
          direction: props.direction,
          streams: props.streams,
          sendEncodings: props.sendEncodings
        });
      }
    },
    toString() {
      var _a;
      return [this.content, this.kind, (_a = this.transceiver) == null ? void 0 : _a.mid].filter(Boolean).join("-");
    }
  };
  return config;
};
var isTransceiverInit = (t) => {
  if (typeof t === "object" && t && "kindOrTrack" in t) {
    return true;
  }
  return false;
};
var isTransceiverConfig = (t) => {
  if (typeof t === "object" && t && "kind" in t && typeof t.kind === "string" && ["audio", "video"].includes(t.kind)) {
    return true;
  }
  return false;
};
var isDataChannelInit = (t) => {
  if (typeof t === "object" && t && "label" in t && typeof t.label === "string") {
    return true;
  }
  return false;
};
var isDataChannelConfig = (t) => {
  if (typeof t === "object" && t && "kind" in t && typeof t.kind === "string" && t.kind === "application") {
    return true;
  }
  return false;
};
var createMediaConfigs = (mediaInits, onTransceiverChanged) => {
  const map = /* @__PURE__ */ new Map();
  const handleTransceiverChanged = (trans, config) => {
    map.set(trans, config);
    logger3.debug({ map, transceiver: trans, config }, "handleTransceiverChanged");
    onTransceiverChanged == null ? void 0 : onTransceiverChanged();
  };
  const mediaConfigs = (mediaInits == null ? void 0 : mediaInits.map((init) => {
    if (isTransceiverInit(init)) {
      const config = createTransceiverConfig(init, handleTransceiverChanged);
      return config;
    }
    return createDataChannelConfig(init);
  })) ?? [];
  function getConfig(key) {
    return map.get(key);
  }
  function addConfig(peer, initOrConfig) {
    if (isTransceiverInit(initOrConfig)) {
      const trackOrKind = initOrConfig.kindOrTrack;
      const transceiver = initOrConfig.transceiver ? initOrConfig.transceiver : peer.addTransceiver(trackOrKind, initOrConfig);
      const config = createTransceiverConfig({ ...initOrConfig, transceiver }, handleTransceiverChanged);
      mediaConfigs.push(config);
      handleTransceiverChanged(transceiver, config);
      return config;
    }
    if (isTransceiverConfig(initOrConfig)) {
      const trackOrKind = initOrConfig.track ?? initOrConfig.kind;
      const transceiver = initOrConfig.transceiver ?? peer.addTransceiver(trackOrKind, initOrConfig);
      mediaConfigs.push(initOrConfig);
      handleTransceiverChanged(transceiver, initOrConfig);
      return initOrConfig;
    }
    if (isDataChannelInit(initOrConfig)) {
      const dataChannel = initOrConfig.dataChannel ?? peer.createDataChannel(initOrConfig.label, initOrConfig);
      const config = createDataChannelConfig({
        ...initOrConfig,
        dataChannel
      });
      mediaConfigs.push(config);
      return config;
    }
    if (!initOrConfig.dataChannel) {
      peer.createDataChannel(initOrConfig.options.label, initOrConfig.options);
    }
    mediaConfigs.push(initOrConfig);
    return initOrConfig;
  }
  return {
    get configs() {
      return mediaConfigs;
    },
    addConfig,
    getConfig,
    find: (predicate) => mediaConfigs.find(predicate)
  };
};
var changeTransceiverDirection = (currentDirection, intendedDirection = "send") => {
  if (intendedDirection !== "send" && intendedDirection !== "recv") {
    return intendedDirection;
  }
  switch (currentDirection) {
    case "inactive": {
      return intendedDirection === "send" ? "sendonly" : "recvonly";
    }
    case "recvonly": {
      return intendedDirection === "send" ? "sendrecv" : "recvonly";
    }
    case "sendonly": {
      return intendedDirection === "send" ? "sendonly" : "sendrecv";
    }
    case "sendrecv":
    default:
      return "sendrecv";
  }
};
var getRelativeDirection = (remoteDirection) => {
  switch (remoteDirection) {
    case "sendonly":
      return "recvonly";
    case "recvonly":
      return "sendonly";
    case "inactive":
      return "inactive";
    case "sendrecv":
    default:
      return "sendrecv";
  }
};
var deriveSendDirectionFromTrack = (intendedDirection, track) => {
  const hasTrack = Boolean(track);
  if (hasTrack || !intendedDirection.includes("send")) {
    return intendedDirection;
  }
  switch (intendedDirection) {
    case "sendonly":
      return "inactive";
    case "sendrecv":
      return "recvonly";
    default:
      return intendedDirection;
  }
};
var createEventQueue = (callback) => {
  const queue = [];
  let buffering = true;
  return {
    get buffering() {
      return buffering;
    },
    set buffering(value) {
      buffering = value;
    },
    get length() {
      return queue.length;
    },
    get items() {
      return [...queue];
    },
    /**
     * Put an item to the end of the queue. When the attribute `buffering`
     * is `false`, it triggers the `callback` immediately instead of putting
     * the item into the queue.
     *
     * @param item - The item to put into the queue
     */
    enqueue: (item) => {
      if (buffering) {
        queue.push(item);
      } else {
        for (const item2 of queue) {
          callback(item2);
        }
        callback(item);
      }
    },
    /**
     * Empty the queue by running the callback with all the items in the
     * queue in-order, and returns the items;
     */
    flush: () => queue.splice(0, queue.length).map((item) => {
      callback(item);
      return item;
    }),
    /**
     * Discard all the items without any side effects
     */
    discard: () => {
      queue.length = 0;
    }
  };
};
var subscribePCEvents = (pc, listeners) => {
  listeners.forEach(({ event, listener, options }) => {
    switch (event) {
      case "datachannel": {
        pc.addEventListener(event, listener, options);
        break;
      }
      case "icecandidate": {
        pc.addEventListener(event, listener, options);
        break;
      }
      case "track": {
        pc.addEventListener(event, listener, options);
        break;
      }
      default: {
        pc.addEventListener(event, listener, options);
        break;
      }
    }
  });
  pc.addEventListener("close", () => {
    listeners.forEach(({ event, listener, options }) => {
      switch (event) {
        case "datachannel": {
          pc.removeEventListener(event, listener, options);
          break;
        }
        case "icecandidate": {
          pc.removeEventListener(event, listener, options);
          break;
        }
        case "track": {
          pc.removeEventListener(event, listener, options);
          break;
        }
        default: {
          pc.removeEventListener(event, listener, options);
          break;
        }
      }
    });
  }, { once: true });
};
var createRTCPeerConnection = (options, listeners, existingPC) => {
  const pc = existingPC ?? new RTCPeerConnection(options);
  listeners && subscribePCEvents(pc, listeners);
  return pc;
};

// node_modules/@pexip/peer-connection/dist/sdpManager.js
var sdpTransform = __toESM(require_lib());
var Codec;
(function(Codec2) {
  Codec2["VP8"] = "VP8";
  Codec2["VP9"] = "VP9";
  Codec2["H264"] = "H264";
})(Codec || (Codec = {}));
var TWCCExtensionUrl = "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions";
var SdpTransformManager = class {
  constructor(sdp, enrichOptions) {
    this.sdp = sdp;
    this.isTWCCsupported = () => {
      var _a;
      return (_a = this.sdp.sdp) == null ? void 0 : _a.includes(TWCCExtensionUrl);
    };
    this.addContentAttribute = (mid, content) => {
      if (!this.sdp.sdp || !content) {
        return;
      }
      let modifiedSdp = this.sdp;
      const transformSdp = sdpTransform.parse(this.sdp.sdp);
      const mline = this.getMediaLine(transformSdp.media, mid);
      if (!mline) {
        return;
      }
      this.setContentAttribute(mline, content);
      modifiedSdp = {
        sdp: sdpTransform.write(transformSdp),
        type: this.sdp.type
      };
      this.sdp = modifiedSdp;
    };
    this.addMsidToMline = (transceiver, msid) => {
      var _a;
      if (!this.sdp.sdp) {
        return;
      }
      let modifiedSdp = this.sdp;
      const transformSdp = sdpTransform.parse(this.sdp.sdp);
      const mLine = transformSdp.media.find((mline) => {
        var _a2;
        if (transceiver.mid) {
          return String(mline.mid) === transceiver.mid && mline.type === (((_a2 = transceiver.sender.track) == null ? void 0 : _a2.kind) ?? transceiver.receiver.track.kind);
        }
      });
      if (!mLine) {
        return;
      }
      const msids = (_a = mLine.msid) == null ? void 0 : _a.split(" ");
      if (msids == null ? void 0 : msids[0]) {
        msids[0] = msid;
      }
      mLine.msid = msids == null ? void 0 : msids.join(" ");
      modifiedSdp = {
        sdp: sdpTransform.write(transformSdp),
        type: this.sdp.type
      };
      this.sdp = modifiedSdp;
    };
    this.setSdp(sdp, enrichOptions);
  }
  setSdp(sdp, enrichOptions) {
    this.sdp = sdp;
    if (enrichOptions) {
      this.enrichSdp(enrichOptions);
    }
  }
  getSdp() {
    return this.sdp;
  }
  getFingerprints() {
    var _a;
    if (!((_a = this.sdp) == null ? void 0 : _a.sdp)) {
      return [];
    }
    const transformSdp = sdpTransform.parse(this.sdp.sdp);
    return [
      transformSdp.fingerprint,
      ...transformSdp.media.map((m) => m.fingerprint)
    ].flatMap((fingerprint) => fingerprint ? [fingerprint] : []);
  }
  enrichSdp(options) {
    var _a;
    let modifiedSdp = this.sdp;
    if ((_a = this.sdp) == null ? void 0 : _a.sdp) {
      let transformSdp = sdpTransform.parse(this.sdp.sdp);
      if (options.contents) {
        transformSdp.media.filter((mline) => mline.type === "audio" || mline.type === "video").forEach((mline, idx) => {
          var _a2;
          mline.content = (_a2 = options.contents) == null ? void 0 : _a2[idx];
        });
      }
      if (options.sendEncodings) {
        transformSdp.media.filter((mline) => mline.type === "audio" || mline.type === "video").forEach((mline, idx) => {
          var _a2;
          const encodings = (_a2 = options.sendEncodings) == null ? void 0 : _a2[idx];
          if (mline.rids && encodings) {
            mline.rids.forEach((rid, i) => {
              const { maxWidth, maxHeight } = (encodings == null ? void 0 : encodings[i]) ?? {};
              const paramArray = rid.params ? rid.params.split(";") : [];
              if (mline.type === "video") {
                if (maxHeight && !paramArray.find((param) => param.includes("max-height="))) {
                  paramArray.push(`max-height=${maxHeight}`);
                }
              }
              if (maxWidth && !paramArray.find((param) => param.includes("max-width="))) {
                paramArray.push(`max-width=${maxWidth}`);
              }
              if (paramArray.length > 0) {
                rid.params = paramArray.join(";");
              }
            });
          }
        });
      }
      if (options.videoAS) {
        transformSdp = this.addBandwidthLine(transformSdp, options.videoAS, options.videoTIAS);
      }
      if (options.allowCodecSdpMunging && !options.allowVP9) {
        transformSdp = this.stripCodecs(transformSdp, [Codec.VP9]);
      }
      if (this.shouldAddSupportForHighQualityStream(options)) {
        transformSdp = this.addSupportForHighQualityStream(transformSdp, options.allow4kPreso);
      }
      if (options.allowCodecSdpMunging) {
        transformSdp = this.chooseVideoPTs(transformSdp);
      }
      modifiedSdp = {
        sdp: sdpTransform.write(transformSdp),
        type: this.sdp.type
      };
    }
    this.sdp = modifiedSdp;
  }
  shouldAddSupportForHighQualityStream(options) {
    var _a;
    return ((_a = options.contents) == null ? void 0 : _a.includes("slides")) || (options == null ? void 0 : options.allow1080p) && options.videoAS && options.videoAS >= 2564;
  }
  setContentAttribute(mline, content) {
    if (!mline || !content) {
      return;
    }
    mline.content = content;
  }
  addBandwidthLine(sdp, videoAS, videoTIAS) {
    const videoLines = this.getVideoLines(sdp.media);
    videoLines.forEach((videoLine) => {
      if (!videoLine.bandwidth) {
        videoLine.bandwidth = [];
      }
      const TIAS = videoLine.bandwidth.find(({ type }) => type === "TIAS");
      const limit = Number(TIAS == null ? void 0 : TIAS.limit);
      if (limit && videoTIAS && limit < videoTIAS) {
        return;
      }
      videoLine.bandwidth.push({
        type: "AS",
        limit: videoAS
      });
      if (videoTIAS) {
        if (TIAS) {
          TIAS.limit = videoTIAS;
        } else {
          videoLine.bandwidth.push({
            type: "TIAS",
            limit: videoTIAS
          });
        }
      }
    });
    return sdp;
  }
  addSupportForHighQualityStream(sdp, allow4kPreso = false) {
    const videoLines = this.getVideoLines(sdp.media);
    videoLines.forEach((videoLine) => {
      const codecs = this.getCodecs(videoLine.rtp);
      videoLine.fmtp = videoLine.fmtp.map((fmtp) => {
        if (fmtp.config.includes("max-fs")) {
          return fmtp;
        }
        const codec = codecs[fmtp.payload];
        const is4kPreso = isPreso(videoLine) && allow4kPreso;
        if (codec === Codec.VP8 || codec === Codec.VP9) {
          fmtp.config += this.getVPXConfigOverrides(is4kPreso);
        } else if (codec === Codec.H264) {
          fmtp.config += this.getH264ConfigOverrides(is4kPreso);
        }
        return fmtp;
      });
    });
    return sdp;
  }
  getVPXConfigOverrides(is4kEnabled = false) {
    return `;max-fs=${is4kEnabled ? "36864" : "8160"};max-fr=30`;
  }
  getH264ConfigOverrides(is4kEnabled = false) {
    return is4kEnabled ? ";max-br=32768;max-mbps=2073600;max-fs=36864;max-smbps=2073600;max-fps=6000;max-fr=30" : ";max-br=3732;max-mbps=245760;max-fs=8192;max-smbps=245760;max-fps=3000;max-fr=30";
  }
  /**
   * This method makes sure we pick set of supported codecs with the right order
   */
  chooseVideoPTs(sdp) {
    const videoLines = this.getVideoLines(sdp.media);
    videoLines.forEach((videoLine) => {
      var _a;
      if (videoLine.port === 0 && this.sdp.type === "answer") {
        return;
      }
      const codecs = this.getCodecs(videoLine.rtp);
      let payloadTypes = [];
      for (const fmtp of videoLine.fmtp) {
        if (codecs[fmtp.payload] !== Codec.H264) {
          continue;
        }
        const params = fmtp.config.split(";");
        const [, profile] = ((_a = params.find((param) => param.includes("profile-level-id"))) == null ? void 0 : _a.split("=")) ?? [];
        const profileIdc = profile == null ? void 0 : profile.substring(0, 2);
        const profileIop = (profile == null ? void 0 : profile.substring(2, 4)) ?? "";
        if (profileIdc !== "42") {
          continue;
        }
        if (parseInt("0x" + profileIop) & 64 && // CB otherwise B
        fmtp.config.includes("packetization-mode=1")) {
          payloadTypes = [fmtp.payload];
          break;
        }
        payloadTypes.push(fmtp.payload);
      }
      videoLine.rtp = videoLine.rtp.filter(({ codec, payload }) => {
        if (codec === Codec.H264) {
          return payloadTypes.includes(payload);
        }
        const fmtp = videoLine.fmtp.find((line) => line.payload === payload);
        return this.shouldStripH264Line((fmtp == null ? void 0 : fmtp.config) ?? "", payloadTypes, codecs);
      });
      videoLine.fmtp = videoLine.fmtp.filter(({ payload, config }) => {
        if (codecs[payload] === Codec.H264 && !payloadTypes.includes(payload)) {
          return false;
        }
        return this.shouldStripH264Line(config, payloadTypes, codecs);
      });
      if (videoLine.rtcpFb) {
        videoLine.rtcpFb = videoLine.rtcpFb.filter(({ payload }) => codecs[payload] !== Codec.H264 || codecs[payload] === Codec.H264 && payloadTypes.includes(payload));
      }
      const payloads = [
        ...payloadTypes,
        ...videoLine.rtp.flatMap(({ payload }) => !payloadTypes.includes(Number(payload)) ? [payload] : [])
      ];
      if (videoLine.payloads && payloads.length > 0) {
        videoLine.payloads = payloads.join(" ");
      }
    });
    return sdp;
  }
  shouldStripH264Line(config, payloadTypes, codecs) {
    const [name, value] = config.split("=");
    if (name === "apt" && value && codecs[value] === Codec.H264 && !payloadTypes.includes(Number(value))) {
      return false;
    }
    return true;
  }
  stripCodecs(sdp, disableCodecs) {
    const videoLines = this.getVideoLines(sdp.media);
    for (const videoLine of videoLines) {
      if (videoLine) {
        const removePayloads = videoLine.rtp.filter(({ codec }) => disableCodecs.includes(codec)).map(({ payload }) => payload);
        if (removePayloads.length > 0) {
          const rtxApts = removePayloads.map((item) => `apt=${item}`);
          const rtxPayloads = videoLine.fmtp.filter((item) => rtxApts.includes(item.config));
          removePayloads.push(...rtxPayloads.map((item) => item.payload));
        }
        if (videoLine.payloads) {
          for (const payload of removePayloads) {
            videoLine.payloads = videoLine.payloads.replace(`${payload} `, "");
          }
        }
        videoLine.rtp = videoLine.rtp.filter((rtp) => !removePayloads.includes(rtp.payload));
        videoLine.fmtp = videoLine.fmtp.filter((fmtp) => !removePayloads.includes(fmtp.payload));
        if (videoLine.rtcpFb) {
          videoLine.rtcpFb = videoLine.rtcpFb.filter((rtcpFb) => !removePayloads.includes(rtcpFb.payload));
        }
      }
    }
    return sdp;
  }
  getVideoLines(media) {
    return media.filter((line) => line.type === "video");
  }
  getMediaLine(media, mid) {
    if (mid) {
      return media.find((line) => (line.type === "video" || line.type === "audio") && String(line.mid) === mid);
    }
  }
  getCodecs(rtp) {
    return rtp.reduce((acc, { codec, payload }) => {
      acc[payload] = codec;
      return acc;
    }, {});
  }
};
var hasICECandidates = (sdp) => {
  if (!sdp) {
    return false;
  }
  const transformedSDP = sdpTransform.parse(sdp);
  return transformedSDP.media.some((m) => m.candidates && m.candidates.length > 0);
};
var getMediaLines = (sdp) => {
  if (!sdp) {
    return [];
  }
  return sdpTransform.parse(sdp).media;
};
var isPreso = (media) => media.content === "slides";

// node_modules/@pexip/peer-connection/dist/peerConnections.js
var MAX_M_CONTENT_COUNT = 10;
var MAX_DEFER_NEGOTIATION_COUNT = 10;
function createPeerConnection(options = {}, peerConnection) {
  const props = {
    bandwidth: options.bandwidth ?? 0,
    offerOptions: options.offerOptions,
    answerOptions: options.answerOptions,
    references: {
      module: "PeerConnection",
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    },
    allowCodecSdpMunging: Boolean(options.allowCodecSdpMunging),
    // Only used when `restartIce` is not available
    iceRestartNeeded: false,
    initialConnectionDone: false,
    makingOffer: false,
    makingAnswer: false,
    ignoreNegotiationNeeded: false,
    pendingOffer: void 0,
    allowVP9: options.allowVP9 ?? true,
    allow1080p: options.allow1080p,
    allow4kPreso: options.allow4kPreso,
    currentRemoteDescription: void 0,
    localFingerprints: [],
    remoteFingerprints: [],
    mediaContentMismatchCount: 0,
    deferNegotiationCount: 0,
    polite: !!options.polite
  };
  const mediaConfigs = createMediaConfigs(options.mediaInits, () => {
    var _a;
    return (_a = eventHandlers.onTransceiverChange) == null ? void 0 : _a.call(eventHandlers);
  });
  let remoteMediaLines = /* @__PURE__ */ new Map();
  const timers = {};
  const clearTimer = (timerKey, onDone) => {
    if (timers[timerKey]) {
      clearTimeout(timers[timerKey]);
      timers[timerKey] = void 0;
      onDone == null ? void 0 : onDone();
    }
  };
  const eventHandlers = {};
  const localICECandidateQueue = createEventQueue((evt) => {
    var _a;
    (_a = eventHandlers.onIceCandidate) == null ? void 0 : _a.call(eventHandlers, evt);
  });
  const pcEventListeners = [
    {
      event: "iceconnectionstatechange",
      listener: (event) => {
        log.info("handle iceconnectionstatechange event", { event });
        const pc = event.currentTarget;
        clearTimer("iceConnectionState", () => {
          log.debug("clears the restart ice timer", { event });
        });
        if (pc.iceConnectionState === "failed") {
          log.debug("restarts ice because it went to failed", {
            event
          });
          restartIce();
        } else if (pc.iceConnectionState === "disconnected") {
          log.debug("schedule ice restart because it went to disconnected", {
            event
          });
          timers.iceConnectionState = window.setTimeout(restartIce, RecoveryTimeout.IceConnectionState);
        }
        if (eventHandlers.iceConnectionStateChange) {
          eventHandlers.iceConnectionStateChange(event);
        }
      }
    },
    {
      event: "signalingstatechange",
      listener: (event) => {
        log.info("handle signalingstatechange event", { event });
        const pc = event.currentTarget;
        if (pc.signalingState === "stable") {
          if (props.iceRestartNeeded && eventHandlers.onIceCandidate) {
            fallbackRestartIce();
          }
        }
        if (eventHandlers.signalingStateChange) {
          eventHandlers.signalingStateChange(event);
        }
      }
    },
    {
      event: "icecandidate",
      listener: (event) => {
        if (!eventHandlers.onIceCandidate) {
          return;
        }
        if (props.makingAnswer || props.makingOffer || localICECandidateQueue.buffering) {
          log.debug("buffering ICE candidate", {
            event,
            makingOffer: props.makingOffer,
            makingAnswer: props.makingAnswer,
            localICECandidateBuffering: localICECandidateQueue.buffering
          });
          localICECandidateQueue.buffering = true;
        }
        localICECandidateQueue.enqueue(event);
      }
    },
    {
      event: "negotiationneeded",
      listener: () => {
        log.info("handle negotiationneeded event", { eventHandlers });
        if (eventHandlers.negotiationNeeded) {
          negotiate();
        }
      }
    },
    {
      event: "track",
      listener: (event) => {
        var _a, _b, _c;
        log.info("handle track event", {
          event,
          remoteMediaLines,
          mediaConfigs
        });
        const config = mediaConfigs.getConfig(event.transceiver) ?? mediaConfigs.find((config2) => {
          if (!isTransceiverConfig(config2)) {
            return false;
          }
          const media = remoteMediaLines.get(event.transceiver.mid ?? "");
          const content = (media == null ? void 0 : media.content) ?? "main";
          const kind = media == null ? void 0 : media.type;
          return kind === config2.kind && content === config2.content;
        });
        if (!isTransceiverConfig(config)) {
          log.warn("Unable to find respective transceiver config", {
            mediaConfigs,
            event
          });
          (_a = eventHandlers.onTrack) == null ? void 0 : _a.call(eventHandlers, event);
          return;
        }
        config.remoteStreams = event.streams.length ? event.streams : [new MediaStream([event.track])];
        (_b = eventHandlers.onRemoteStreams) == null ? void 0 : _b.call(eventHandlers, config);
        (_c = eventHandlers.onTrack) == null ? void 0 : _c.call(eventHandlers, event);
      }
    },
    {
      event: "datachannel",
      listener: (event) => {
        var _a;
        log.info("handle datachannel event", {
          event,
          eventHandler: eventHandlers.onDataChannel
        });
        const config = mediaConfigs.find((config2) => isDataChannelConfig(config2) && !config2.dataChannel);
        if (isDataChannelConfig(config)) {
          config.dataChannel = event.channel;
        }
        (_a = eventHandlers.onDataChannel) == null ? void 0 : _a.call(eventHandlers, event);
      }
    }
  ];
  const peer = createRTCPeerConnection(options.rtcConfig, pcEventListeners, peerConnection);
  if (typeof peer.peerIdentity === "object") {
    peer.peerIdentity.catch((error) => {
      log.error("peerIdentity error", { error });
      peer.close();
    });
  }
  const log = createRefsLog(() => ({
    ...logReferences(props.references),
    ...getPeerConnectionStates(peer),
    props
  }));
  const associateStream = ({ transceiver, stream, sdp, sdpOptions }) => {
    const sdpManager = sdp instanceof SdpTransformManager ? sdp : new SdpTransformManager(sdp, sdpOptions);
    sdpManager.addMsidToMline(transceiver, stream.id);
  };
  const associateStreamWithSDP = ({ streams, transceiver }, sdp, sdpOptions) => {
    const [stream] = streams;
    if (!stream || !transceiver) {
      return;
    }
    log.debug("Manual associate stream with SDP", {
      sdp,
      options: sdpOptions,
      stream,
      currentLocalDescription: peer.currentLocalDescription,
      transceivers: peer.getTransceivers(),
      transceiver
    });
    associateStream({
      transceiver,
      stream,
      sdp,
      sdpOptions
    });
  };
  const setLocalStream = async (mediaStream, targets, shouldSyncMedia = true) => {
    var _a;
    log.info("call setLocalStream", { mediaStream, targets });
    const streams = mediaStream ? [mediaStream] : [];
    for (const [config, intentDirection] of targets) {
      const direction = changeTransceiverDirection(((_a = config.transceiver) == null ? void 0 : _a.currentDirection) ?? config.direction, intentDirection);
      const track = (mediaStream == null ? void 0 : mediaStream.getTracks().find((track2) => track2.kind === config.kind && track2.readyState === "live")) ?? null;
      config.track = track;
      config.streams = streams;
      config.direction = direction;
    }
    if (shouldSyncMedia) {
      await syncMedia(remoteMediaLines, true);
    }
  };
  const negotiate = () => {
    clearTimer("negotiation");
    if (props.mediaContentMismatchCount >= MAX_M_CONTENT_COUNT) {
      log.info("Failed to negotiate with remote peer because of transceiver content attribute mismatch");
      props.mediaContentMismatchCount = 0;
      return;
    }
    if (props.deferNegotiationCount >= MAX_DEFER_NEGOTIATION_COUNT) {
      log.info("Defer negotiation is more than allowed");
      props.deferNegotiationCount = 0;
      return;
    }
    if (eventHandlers.negotiationNeeded) {
      if (!props.ignoreNegotiationNeeded && !props.makingOffer && peer.signalingState === "stable") {
        log.info("call negotiationneeded handler");
        props.deferNegotiationCount = 0;
        eventHandlers.negotiationNeeded();
      } else {
        log.info("defer negotiation", {
          ignoreNegotiationNeeded: props.ignoreNegotiationNeeded,
          makingOffer: props.makingOffer,
          signalingState: peer.signalingState
        });
        props.deferNegotiationCount += 1;
        timers.negotiation = window.setTimeout(negotiate, RecoveryTimeout.Negotiation);
      }
    } else {
      log.warn("[negotiate] try to negotiate but no negotiationneeded handler");
    }
  };
  const fallbackRestartIce = () => {
    log.info("[restartIce fallback] trigger negotiationneeded manually");
    props.offerOptions = { ...props.offerOptions, iceRestart: true };
    props.iceRestartNeeded = false;
    negotiate();
  };
  const restartIce = () => {
    if (!eventHandlers.onIceCandidate) {
      return;
    }
    clearTimer("connectionState", () => {
      log.debug("clears connectionStateTimer due to iceRestart");
    });
    if (peer.restartIce !== void 0) {
      log.info("restartIce");
      peer.restartIce();
    } else {
      if (peer.signalingState === "stable") {
        log.info("restartIce fallback");
        fallbackRestartIce();
      } else {
        props.iceRestartNeeded = true;
        log.info("restartIce fallback deferred");
      }
    }
  };
  const calculateSecureCheckCode = async () => {
    var _a;
    log.info("calculateSecureCheckCode");
    if (props.localFingerprints.length && props.remoteFingerprints.length) {
      const local = props.localFingerprints.map(({ type, hash }) => type + hash).sort().join("");
      const remote = props.remoteFingerprints.map(({ type, hash }) => type + hash).sort().join("");
      const msg = [local, remote].sort().join("");
      const msgBuffer = new TextEncoder().encode(msg);
      const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
      (_a = eventHandlers.onSecureCheckCode) == null ? void 0 : _a.call(eventHandlers, hashHex);
    }
  };
  const syncMedia = async (remoteMediaLines2, active) => {
    if (peer.connectionState === "closed") {
      return;
    }
    const currentTransceivers = peer.getTransceivers();
    log.info("Sync Media", {
      currentTransceivers,
      mediaConfigs,
      remoteMediaLines: remoteMediaLines2,
      active
    });
    try {
      props.ignoreNegotiationNeeded = true;
      const transceivers = new Map(currentTransceivers.flatMap((trans) => isTransceiverObsolete(trans) ? [] : [[trans.mid, trans]]));
      for (const remoteMedia of remoteMediaLines2.values()) {
        const remoteContent = remoteMedia.content ?? "main";
        const mid = String(remoteMedia.mid);
        const relativeDirection = active ? void 0 : getRelativeDirection(remoteMedia.direction);
        switch (remoteMedia.type) {
          case "application": {
            const config = mediaConfigs.find((config2) => isDataChannelConfig(config2) && !!config2.options.negotiated && String(config2.options.id) === mid);
            if (config) {
              log.debug(`Sync existing ${config} data channel config`, {
                remoteMedia,
                config,
                mediaConfigs
              });
              config.syncDataChannel(peer);
            }
            break;
          }
          case "audio":
          case "video": {
            const transceiver = transceivers.get(mid);
            if (!transceiver) {
              throw new Error(`Cannot find respective Transceiver with mid:${mid}`);
            }
            const existingConfig = mediaConfigs.getConfig(transceiver);
            if (existingConfig) {
              log.debug(`Sync existing ${existingConfig} transceiver config`, {
                transceiver,
                remoteMedia,
                mediaConfigs
              });
              if (existingConfig.content !== remoteContent) {
                log.warn(`(local:content) ${existingConfig.content} <==> (remote:content) ${remoteMedia.content}`, { remoteMedia, localConfig: existingConfig });
                props.mediaContentMismatchCount++;
                continue;
              }
              await existingConfig.syncTransceiver(peer, {
                direction: existingConfig.relativeDirection ? relativeDirection : void 0
              });
            } else {
              const matchedConfig = mediaConfigs.find((config) => {
                return isTransceiverConfig(config) && (!config.transceiver || isTransceiverObsolete(config.transceiver)) && // Assume it is `main` when no content attribute is set
                config.content === remoteContent && config.kind === remoteMedia.type;
              });
              if (matchedConfig) {
                log.debug(`found matched ${matchedConfig} transceiver config`, {
                  transceiver,
                  matchedConfig,
                  remoteMedia
                });
                matchedConfig.transceiver = transceiver;
                await matchedConfig.syncTransceiver(peer, {
                  direction: matchedConfig.relativeDirection ? relativeDirection : void 0
                });
              } else {
                log.debug("Transceiver config mismatched, adding a new config", { transceiver, remoteMedia, mediaConfigs });
                const newConfig = mediaConfigs.addConfig(peer, {
                  kindOrTrack: transceiver.sender.track ?? remoteMedia.type,
                  content: remoteMedia.content ?? "main",
                  transceiver,
                  direction: relativeDirection
                });
                await newConfig.syncTransceiver(peer);
              }
            }
            break;
          }
          default: {
            break;
          }
        }
      }
      if (!active) {
        return;
      }
      for (const config of mediaConfigs.configs) {
        if (isTransceiverConfig(config)) {
          await config.syncTransceiver(peer);
        }
        if (isDataChannelConfig(config)) {
          config.syncDataChannel(peer);
        }
      }
    } finally {
      props.ignoreNegotiationNeeded = false;
      props.initialConnectionDone = true;
    }
  };
  const createOffer = async (offerOptions) => {
    log.info("call createOffer", { param: offerOptions, peer });
    props.makingOffer = true;
    try {
      const sdp = await peer.createOffer({
        ...props.offerOptions,
        ...offerOptions
      });
      log.debug("created raw Offer", { sdp });
      const sdpManager = new SdpTransformManager(sdp, {
        allow1080p: props.allow1080p,
        allow4kPreso: props.allow4kPreso,
        allowCodecSdpMunging: props.allowCodecSdpMunging,
        allowVP9: props.allowVP9,
        contents: mediaConfigs.configs.flatMap((config) => isTransceiverConfig(config) ? [config.content] : []),
        sendEncodings: mediaConfigs.configs.flatMap((config) => isTransceiverConfig(config) ? [config.sendEncodings ?? []] : []),
        videoAS: props.bandwidth
      });
      let offer = sdpManager.getSdp();
      if (peer.signalingState !== "stable") {
        throw new Error("Ignore");
      }
      await peer.setLocalDescription(offer);
      if (!CAN_SET_STREAMS) {
        mediaConfigs.configs.forEach((config) => {
          if (config.kind === "video" || config.kind === "audio") {
            associateStreamWithSDP(config, sdpManager);
          }
        });
      }
      offer = sdpManager.getSdp();
      log.info("setLocalDescription with offer success", {
        rawSDP: sdp,
        offer
      });
      props.localFingerprints = sdpManager.getFingerprints();
      await calculateSecureCheckCode();
      return offer;
    } finally {
      props.makingOffer = false;
    }
  };
  return {
    get peer() {
      return peer;
    },
    get polite() {
      return props.polite;
    },
    get iceGatheringState() {
      return peer.iceGatheringState;
    },
    get iceConnectionState() {
      return peer.iceConnectionState;
    },
    get signalingState() {
      return peer.signalingState;
    },
    get connectionState() {
      return peer.connectionState;
    },
    get senders() {
      return peer.getSenders();
    },
    get receivers() {
      return peer.getReceivers();
    },
    get configs() {
      return mediaConfigs.configs;
    },
    getTransceiverConfigs: () => {
      return mediaConfigs.configs.filter(isTransceiverConfig);
    },
    getDataChannelConfigs: () => {
      return mediaConfigs.configs.filter(isDataChannelConfig);
    },
    addConfig: mediaConfigs.addConfig,
    releaseLocalICECandidatesBuffer: (ignore) => {
      if (!eventHandlers.onIceCandidate) {
        return;
      }
      localICECandidateQueue.buffering = false;
      if (!ignore && localICECandidateQueue.length) {
        const eventFlushed = localICECandidateQueue.flush();
        log.debug("Release buffered local ICE candidates", {
          events: eventFlushed
        });
        return;
      }
      localICECandidateQueue.discard();
    },
    get hasICECandidates() {
      var _a, _b;
      return hasICECandidates(((_a = peer.pendingLocalDescription) == null ? void 0 : _a.sdp) ?? ((_b = peer.currentLocalDescription) == null ? void 0 : _b.sdp));
    },
    get currentLocalDescription() {
      if (peer.currentLocalDescription !== void 0) {
        return peer.currentLocalDescription;
      }
      return peer.localDescription;
    },
    get pendingLocalDescription() {
      if (peer.pendingLocalDescription !== void 0) {
        return peer.pendingLocalDescription ?? void 0;
      }
      return peer.signalingState === "stable" || peer.localDescription === null ? void 0 : peer.localDescription;
    },
    get currentRemoteDescription() {
      if (peer.currentRemoteDescription !== void 0) {
        return peer.currentRemoteDescription;
      }
      return peer.remoteDescription;
    },
    get pendingRemoteDescription() {
      if (peer.pendingRemoteDescription !== void 0) {
        return peer.pendingRemoteDescription;
      }
      return peer.signalingState === "stable" ? null : peer.remoteDescription;
    },
    get bandwidth() {
      return props.bandwidth;
    },
    get references() {
      return props.references;
    },
    get offerOptions() {
      return props.offerOptions;
    },
    set offerOptions(newOptions) {
      props.offerOptions = { ...props.offerOptions, ...newOptions };
    },
    get answerOptions() {
      return props.answerOptions;
    },
    set answerOptions(newOptions) {
      log.info("set answerOptions", {
        newOptions,
        answerOptions: props.answerOptions
      });
      props.answerOptions = { ...props.answerOptions, ...newOptions };
    },
    set bandwidth(bandwidth) {
      log.info("set bandwidth", {
        newBandwidth: bandwidth,
        bandwidth: props.bandwidth
      });
      if (props.bandwidth !== bandwidth) {
        props.bandwidth = bandwidth;
        negotiate();
      }
    },
    set negotiationNeeded(needed) {
      if (needed) {
        negotiate();
      }
    },
    negotiate: async () => {
      return syncMedia(remoteMediaLines, true);
    },
    getStats: async (selector) => await peer.getStats(selector),
    setLocalStream,
    setReference(key, value) {
      log.info("call setReference", {
        references: props.references,
        key,
        value
      });
      props.references[key] = value;
    },
    createDataChannel: (label, dataChannelDict) => {
      log.info("call createDataChannel", { label, dataChannelDict });
      return peer.createDataChannel(label, dataChannelDict);
    },
    createOffer,
    createAnswer: async (answerOptions) => {
      log.info("call createAnswer", { param: answerOptions });
      props.makingAnswer = true;
      try {
        const sdp = await peer.createAnswer({
          ...props.answerOptions,
          ...answerOptions
        });
        log.debug("created raw Answer", { sdp });
        const sdpManager = new SdpTransformManager(sdp, {
          allow4kPreso: props.allow4kPreso,
          allowCodecSdpMunging: props.allowCodecSdpMunging,
          allowVP9: props.allowVP9,
          videoAS: props.bandwidth
        });
        mediaConfigs.configs.forEach((config) => {
          var _a;
          if (isTransceiverConfig(config) && ((_a = config.transceiver) == null ? void 0 : _a.mid)) {
            sdpManager.addContentAttribute(config.transceiver.mid, config.content);
          }
        });
        let answer = sdpManager.getSdp();
        await peer.setLocalDescription(answer);
        if (!CAN_SET_STREAMS) {
          mediaConfigs.configs.forEach((config) => {
            if (config.kind === "video" || config.kind === "audio") {
              associateStreamWithSDP(config, sdpManager);
            }
          });
        }
        answer = sdpManager.getSdp();
        log.info("setLocalDescription with answer success", {
          rawSDP: sdp,
          answer
        });
        props.localFingerprints = sdpManager.getFingerprints();
        await calculateSecureCheckCode();
        return answer;
      } finally {
        props.makingAnswer = false;
      }
    },
    receiveAnswer: async (answer) => {
      log.info("call receiveAnswer", { answer });
      remoteMediaLines = new Map(getMediaLines(answer.sdp).map((mline) => [
        String(mline.mid),
        mline
      ]));
      const sdpManager = new SdpTransformManager(answer, {
        allowCodecSdpMunging: props.allowCodecSdpMunging,
        allowVP9: props.allowVP9,
        videoAS: props.bandwidth,
        videoTIAS: props.bandwidth * 1e3
      });
      await peer.setRemoteDescription(sdpManager.getSdp());
      log.debug("setRemoteDescription success", {
        currentTransceivers: peer.getTransceivers(),
        mediaConfigs
      });
      props.remoteFingerprints = sdpManager.getFingerprints();
      await calculateSecureCheckCode();
      props.currentRemoteDescription = answer;
    },
    receiveOffer: async (offer) => {
      log.info("call receiveOffer", { offer });
      remoteMediaLines = new Map(getMediaLines(offer.sdp).map((mline) => [
        String(mline.mid),
        mline
      ]));
      props.currentRemoteDescription = offer;
      props.remoteFingerprints = new SdpTransformManager(offer).getFingerprints();
      await peer.setRemoteDescription(offer);
      await syncMedia(remoteMediaLines, false);
      await calculateSecureCheckCode();
    },
    receiveIceCandidate: async (candidate) => {
      log.info("call receiveIceCandidate", { candidate });
      await peer.addIceCandidate(candidate);
    },
    restartIce,
    getConfiguration: () => peer.getConfiguration(),
    setConfiguration: typeof peer.setConfiguration === "function" ? (rtcConfig) => peer.setConfiguration(rtcConfig) : void 0,
    close: () => {
      log.info("call close");
      localICECandidateQueue.discard();
      props.deferNegotiationCount = 0;
      props.mediaContentMismatchCount = 0;
      remoteMediaLines = /* @__PURE__ */ new Map();
      Object.keys(timers).forEach((key) => {
        clearTimer(key);
      });
      peer.close();
    },
    // Event handlers
    set onConnectionStateChange(handler) {
      peer.onconnectionstatechange = (event) => {
        clearTimer("connectionState", () => {
          log.debug("clears the connection state timer", { event });
        });
        if (["disconnected", "failed"].includes(peer.connectionState)) {
          log.debug(`waits for emitting connection state change because it is "${peer.connectionState}"`, { event });
          timers.connectionState = window.setTimeout(() => {
            log.debug("emits connection state change after waiting for ice restart", { event });
            handler == null ? void 0 : handler(event);
          }, RecoveryTimeout.ConnectionState);
        } else {
          handler == null ? void 0 : handler(event);
        }
      };
    },
    set onDataChannel(handler) {
      eventHandlers.onDataChannel = handler;
    },
    set onIceCandidate(handler) {
      eventHandlers.onIceCandidate = handler;
    },
    set onIceCandidateError(handler) {
      peer.onicecandidateerror = handler;
    },
    set onIceConnectionStateChange(handler) {
      eventHandlers.iceConnectionStateChange = handler;
    },
    set onIceGatheringStateChange(handler) {
      peer.onicegatheringstatechange = handler ?? null;
    },
    set onNegotiationNeeded(handler) {
      eventHandlers.negotiationNeeded = handler;
    },
    set onSignalingStateChange(handler) {
      eventHandlers.signalingStateChange = handler;
    },
    set onTransceiverChange(handler) {
      eventHandlers.onTransceiverChange = handler;
    },
    set onSecureCheckCode(handler) {
      eventHandlers.onSecureCheckCode = handler;
    },
    set onTrack(handler) {
      eventHandlers.onTrack = handler;
    },
    set onRemoteStreams(handler) {
      eventHandlers.onRemoteStreams = handler;
    }
  };
}
function createMainPeerConnection(signals, options = {}) {
  const peer = createPeerConnection(options);
  peer.setReference("module", "MainPeerConnection");
  const { onOfferRequired, ...restSignals } = signals;
  const log = createRefsLog(createGetRefs(peer));
  let subscriptions = [
    // Handler common signals
    ...withSignals(peer)(restSignals),
    onOfferRequired.add(async (param) => {
      log.info("handle onOfferRequired signal", { param });
      if ((param == null ? void 0 : param.stream) && param.target) {
        try {
          await peer.setLocalStream(param.stream, param.target);
        } catch (error) {
          log.error("setLocalStream failed", { error });
          peer.negotiationNeeded = true;
        }
      } else {
        await peer.negotiate();
      }
    })
  ];
  const cleanup = () => {
    subscriptions = subscriptions.flatMap((unsubscribe) => {
      unsubscribe();
      return [];
    });
  };
  return {
    get peer() {
      return peer.peer;
    },
    get polite() {
      return peer.polite;
    },
    get connectionState() {
      return peer.connectionState;
    },
    get iceConnectionState() {
      return peer.iceConnectionState;
    },
    get iceGatheringState() {
      return peer.iceGatheringState;
    },
    get signalingState() {
      return peer.signalingState;
    },
    get senders() {
      return peer.senders;
    },
    get receivers() {
      return peer.receivers;
    },
    get hasICECandidates() {
      return peer.hasICECandidates;
    },
    get bandwidth() {
      return peer.bandwidth;
    },
    get references() {
      return peer.references;
    },
    set bandwidth(bandwidth) {
      peer.bandwidth = bandwidth;
    },
    get offerOptions() {
      return peer.offerOptions;
    },
    get answerOptions() {
      return peer.answerOptions;
    },
    set offerOptions(newOptions) {
      peer.offerOptions = newOptions;
    },
    set answerOptions(newOptions) {
      peer.answerOptions = newOptions;
    },
    get configs() {
      return peer.configs;
    },
    // Methods
    setLocalStream: peer.setLocalStream,
    setReference(key, value) {
      peer.setReference(key, value);
    },
    getStats: (selector) => peer.getStats(selector),
    getTransceiverConfigs: peer.getTransceiverConfigs,
    getDataChannelConfigs: peer.getDataChannelConfigs,
    addConfig: peer.addConfig,
    createDataChannel: (label, dataChannelDict) => peer.createDataChannel(label, dataChannelDict),
    restartIce: peer.restartIce,
    getConfiguration: peer.getConfiguration,
    setConfiguration: peer.setConfiguration,
    close: () => {
      cleanup();
      peer.close();
    }
  };
}

// node_modules/@pexip/vpaas-sdk/dist/baseLogger.js
var LogLevels4;
(function(LogLevels5) {
  LogLevels5[LogLevels5["trace"] = 10] = "trace";
  LogLevels5[LogLevels5["debug"] = 20] = "debug";
  LogLevels5[LogLevels5["info"] = 30] = "info";
  LogLevels5[LogLevels5["warn"] = 40] = "warn";
  LogLevels5[LogLevels5["error"] = 50] = "error";
  LogLevels5[LogLevels5["fatal"] = 60] = "fatal";
  LogLevels5[LogLevels5["silent"] = Number.MAX_SAFE_INTEGER] = "silent";
})(LogLevels4 || (LogLevels4 = {}));
function createConsoleLogger4() {
  return Object.freeze({
    /* eslint-disable no-console -- set logger to console */
    fatal: (meta, message) => console.error(message, meta),
    error: (meta, message) => console.error(message, meta),
    warn: (meta, message) => console.warn(message, meta),
    info: (meta, message) => console.info(message, meta),
    debug: (meta, message) => console.debug(message, meta),
    trace() {
    },
    // Noop
    silent() {
    },
    // Noop
    redact() {
    }
    // Noop
    /* eslint-enable no-console -- set logger to console */
  });
}

// node_modules/@pexip/vpaas-sdk/dist/logger.js
var logger4 = createConsoleLogger4();
var setLogger4 = (newLogger) => {
  logger4 = newLogger;
};

// node_modules/@pexip/vpaas-sdk/dist/constants.js
var AbortReason;
(function(AbortReason2) {
  AbortReason2["Close"] = "close";
})(AbortReason || (AbortReason = {}));
var MAX_RECONNECT_ATTEMPTS2 = 8;
var BACKOFF_BASE_SETTINGS2 = { min: 100, max: 3e4, jitter: 0.2 };

// node_modules/@pexip/vpaas-sdk/dist/utils.js
var createVpaasSignals = () => ({
  onRosterUpdate: createSignal({
    name: "mee:onRosterUpdate"
  }),
  onMediaOffer: createSignal({
    name: "mee:onMediaOffer"
  }),
  onReconnecting: createSignal({
    name: "mee:reconnecting"
  }),
  onReconnected: createSignal({
    name: "mee:reconnecting"
  }),
  onRemoteStreams: createSignal({
    name: "mee:onRemoteStreams"
  }),
  onError: createSignal({
    name: "mee:onError"
  })
});
var createSocketSignals2 = () => createSocketSignals();
var createRecvTransceivers = (kind, length, content) => Array.from({ length }, () => ({
  direction: "recvonly",
  kindOrTrack: kind,
  content
}));
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var ANONYMOUS_FN = "Anonymous";
var getName = (observer) => {
  return observer.name || ANONYMOUS_FN;
};
var retriable = async (fn, backoff = new Backoff(BACKOFF_BASE_SETTINGS2), retries = MAX_RECONNECT_ATTEMPTS2) => {
  try {
    return await fn();
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      logger4.warn({ error }, `${getName(fn)} aborted`);
      throw error;
    }
    if (retries === 0) {
      logger4.error({ error }, `${getName(fn)} failed`);
      throw error;
    }
    if (error instanceof BadRequestError) {
      logger4.warn({ error }, `${getName(fn)} has bad request. No point of retrying`);
      throw error;
    }
    if (error instanceof NotFoundError) {
      logger4.warn({ error }, `${getName(fn)} not found. No point of retrying`);
      throw error;
    }
    if (error instanceof GoneError) {
      logger4.warn({ error }, `${getName(fn)} gone. No point of retrying`);
      throw error;
    }
    logger4.error({ error, retries }, `retrying ${getName(fn)}`);
    await sleep(backoff.duration());
    return await retriable(fn, backoff, retries - 1);
  }
};
var isSendConfig = (config) => config.direction === "sendonly";
var isInactiveConfig = (config) => config.direction === "inactive";
var isRecvConfig = (config) => config.direction === "recvonly";
var isMainConfig = (config) => config.content === "main";
var isPresoConfig = (config) => config.content === "slides";
var isAudioConfig = (config) => config.kind === "audio";
var isVideoConfig = (config) => config.kind === "video";
var isMainSendConfig = (config) => [isMainConfig, isSendConfig].every((fn) => fn(config));
var isPresoInactiveConfig = (config) => [isPresoConfig, isInactiveConfig].every((fn) => fn(config));
var isPresoRecvConfig = (config) => [isPresoConfig, isRecvConfig].every((fn) => fn(config));
var isPresoSendConfig = (config) => [isPresoConfig, isSendConfig].every((fn) => fn(config));
var isPresoVideo = (config) => [isPresoConfig, isVideoConfig].every((fn) => fn(config));
var WebsocketError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "WebsocketError";
  }
};
var ResourceUnavailableError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ResourceUnavailableError";
  }
};
var MeetingFullError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "MeetingFullError";
  }
};
var TRACE_CHARS = "0123456789abcdef";
var getRandomString = (length, chars = TRACE_CHARS) => Array.from({ length }, (_, i) => i).reduce((acc) => acc + chars[Math.random() * chars.length | 0], "");
var getTraceparent = () => `00-${getRandomString(32)}-${getRandomString(16)}-01`;
var isResponseError = (error) => {
  if (error && typeof error === "object" && "type" in error && error.type === "error" && "error_type" in error && "error_message" in error) {
    return true;
  }
  return false;
};

// node_modules/@pexip/vpaas-sdk/dist/call.js
var toIceCandidate = (ice) => ({
  candidate: ice.candidate,
  mid: ice.sdpMid ?? "0",
  ufrag: ice.usernameFragment ?? "",
  pwd: ""
  // this should be optional in the `AddNewCandidate` type
});
var createCall = ({ meeSignals, socketSignals, socket, mediaInits, abortController, props }) => {
  const pcSignals = createPCSignals([
    "onIceCandidate",
    "onRemoteStreams",
    "onConnectionStateChange"
  ]);
  const pc = createMainPeerConnection(pcSignals, {
    mediaInits,
    rtcConfig: {
      bundlePolicy: "max-bundle"
    }
  });
  window.pexDebug = { ...window.pexDebug, pc };
  const handleAbort = () => {
    if (pc.peer.connectionState === "connecting") {
      close();
    }
  };
  abortController == null ? void 0 : abortController.signal.addEventListener("abort", handleAbort, {
    once: true
  });
  let detachSocketSignals = [];
  let detachPCSignals = [
    pcSignals.onConnectionStateChange.add((connectionState) => {
      if (["connected", "failed"].includes(connectionState)) {
        abortController == null ? void 0 : abortController.signal.removeEventListener("abort", handleAbort);
      }
    }),
    pcSignals.onOffer.add(({ sdp }) => {
      if (!sdp) {
        return;
      }
      socket.send({
        type: "media_offer",
        sdp,
        trace: props == null ? void 0 : props.trace
      });
    }),
    pcSignals.onRemoteStreams.add((streams) => {
      logger4.debug({ streams }, "Remote streams received");
      meeSignals.onRemoteStreams.emit(streams);
    })
  ];
  if (props == null ? void 0 : props.sendCandidates) {
    const sendCandidate = (candidate) => {
      if (!candidate) {
        logger4.debug("End of candidates");
        return;
      }
      socket.send({
        type: "add_new_candidate",
        ...toIceCandidate(candidate),
        trace: props == null ? void 0 : props.trace
      });
    };
    const outgoingICECandidateQueue = createEventQueue(sendCandidate);
    const releaseOutGoingCandidateBuffer = () => {
      outgoingICECandidateQueue.buffering = false;
      const candidatesFlushed = outgoingICECandidateQueue.flush();
      logger4.debug({ outgoingCandidates: candidatesFlushed }, "release buffered outgoing candidates");
    };
    detachSocketSignals.push(socketSignals.onMessage.add((msg) => {
      if (msg.type === "media_offer") {
        releaseOutGoingCandidateBuffer();
      }
    }));
    detachPCSignals.push(pcSignals.onIceCandidate.add(outgoingICECandidateQueue.enqueue));
  }
  detachSocketSignals.push(socketSignals.onMessage.add((msg) => {
    switch (msg.type) {
      case "media_offer":
        meeSignals.onMediaOffer.emit(msg);
        pcSignals.onReceiveAnswer.emit(new RTCSessionDescription({
          sdp: msg.sdp,
          type: "answer"
        }));
        break;
      case "roster_update":
        meeSignals.onRosterUpdate.emit(msg.participants);
        break;
      default:
        break;
    }
  }));
  const setStream = (stream) => {
    pcSignals.onOfferRequired.emit({
      stream,
      target: pc.getTransceiverConfigs().flatMap((config) => isMainConfig(config) && config.direction === "sendonly" ? [[config]] : [])
    });
  };
  const present = (presentationStream) => {
    try {
      const [audioTrack] = (presentationStream == null ? void 0 : presentationStream.getAudioTracks()) ?? [];
      const [videoTrack] = (presentationStream == null ? void 0 : presentationStream.getVideoTracks()) ?? [];
      logger4.debug({
        presentationStream,
        audioTrack,
        videoTrack
      }, "Present");
      pc.addConfig(pc.peer, {
        content: "slides",
        direction: "sendonly",
        kindOrTrack: videoTrack ?? "video",
        streams: presentationStream && videoTrack ? [presentationStream] : []
      });
    } catch (error) {
      logger4.error({ error }, "Presenting failed");
    }
  };
  const stopPresenting = () => {
    pc.getTransceiverConfigs().forEach((config) => {
      var _a, _b;
      if (isPresoVideo(config) && ((_a = config == null ? void 0 : config.transceiver) == null ? void 0 : _a.direction) !== "stopped") {
        (_b = config.transceiver) == null ? void 0 : _b.stop();
      }
    });
  };
  const cleanup = () => {
    detachSocketSignals.forEach((detach) => detach());
    detachSocketSignals = [];
    detachPCSignals.forEach((detach) => detach());
    detachPCSignals = [];
  };
  const close = () => {
    cleanup();
    if (pc.connectionState === "closed") {
      return;
    }
    pc.close();
  };
  pcSignals.onOfferRequired.emit();
  return {
    get pc() {
      return pc;
    },
    setStream,
    present,
    stopPresenting,
    close
  };
};

// node_modules/@pexip/vpaas-sdk/dist/types.js
var VpaasError;
(function(VpaasError2) {
  VpaasError2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  VpaasError2["AUTHENTICATION_FAILED"] = "AUTHENTICATION_FAILED";
  VpaasError2["MEETING_FULL"] = "MEETING_FULL";
  VpaasError2["RECONNECTION_FAILED"] = "RECONNECTION_FAILED";
  VpaasError2["MEETING_EXPIRED"] = "MEETING_EXPIRED";
  VpaasError2["MEETING_NOT_FOUND"] = "MEETING_NOT_FOUND";
})(VpaasError || (VpaasError = {}));

// node_modules/@pexip/vpaas-sdk/dist/vpaas.js
var createVpaas = ({ vpaasSignals, config, socketSignals = createSocketSignals2() }) => {
  const props = {
    trace: config.trace,
    sendCandidates: config.sendCandidates ?? false,
    mediaInits: []
  };
  const { trace } = props;
  const api = createApi();
  const promiseMap = /* @__PURE__ */ new Map();
  let socket;
  let call;
  let detachSignals = [];
  let rejoinAttempt = 0;
  socketSignals.onMessage.add((msg) => {
    const ref = msg.ref ?? "";
    const promiseHandlers = promiseMap.get(ref);
    if (!promiseHandlers) {
      return;
    }
    if (msg.type === "error" || msg.type === "server_error") {
      promiseHandlers.reject(msg);
    } else {
      promiseHandlers.resolve(msg);
    }
    promiseMap.delete(ref);
  });
  const send = (params) => {
    const ref = socket.send({ ...params, trace });
    const promise = new Promise((resolve, reject) => {
      ref && promiseMap.set(ref, { resolve, reject });
    });
    return promise;
  };
  const joinMeeting = async (args) => {
    const { apiAddress, abortController, meetingId, participantId, participantSecret, retry } = args;
    socket = createSocketManager(socketSignals);
    let meetingDetails;
    try {
      logger4.debug({ meetingId, participantId }, "Join Meeting");
      const _join = async (retry2 = false) => {
        const abortSignal = abortController == null ? void 0 : abortController.signal;
        const join = () => api.join({
          abortSignal,
          apiAddress,
          meetingId,
          participantId,
          participantSecret,
          headers: {
            ...trace
          }
        });
        const data = meetingDetails ?? (await (retry2 ? retriable(join) : join())).data;
        meetingDetails = data;
        await socket.connect({
          url: data.location,
          abortController
        });
        return data;
      };
      const _authenticate = async (data) => {
        try {
          await send({
            type: "authenticate",
            token: data.token,
            participant_id: participantId,
            trace
          });
        } catch (e) {
          if (isResponseError(e)) {
            if (e.error_type === "resource_unavailable") {
              if (e.error_message === "Meeting is full") {
                throw new MeetingFullError(e.error_message);
              }
              throw new ResourceUnavailableError(e.error_message ?? e.error_type);
            }
            throw new WebsocketError(e.error_message ?? e.error_type);
          }
          throw new WebsocketError("Unknown error");
        }
      };
      await _authenticate(await _join(retry));
      const _reconnect = async () => {
        try {
          logger4.debug("Reconnecting");
          const _tryReconnect = async () => {
            disconnect();
            await _authenticate(await _join(true));
          };
          vpaasSignals.onReconnecting.emit();
          await retriable(_tryReconnect);
          if (call) {
            connect(props);
          }
          vpaasSignals.onReconnected.emit();
          logger4.debug("Reconnected");
        } catch (error) {
          logger4.error("Reconnecting failed");
          vpaasSignals.onError.emit(VpaasError.RECONNECTION_FAILED);
        }
      };
      const _rejoin = async () => {
        try {
          logger4.debug("Rejoining");
          vpaasSignals.onReconnecting.emit();
          await retriable(() => joinMeeting({ ...args, retry: true }));
          if (call) {
            connect(props);
          }
          rejoinAttempt = 0;
          vpaasSignals.onReconnected.emit();
          logger4.debug("Rejoined");
        } catch (error) {
          logger4.error("Rejoining failed");
          vpaasSignals.onError.emit(VpaasError.RECONNECTION_FAILED);
        }
      };
      detachSignals.push(socketSignals.onReconnected.add(async () => {
        try {
          logger4.debug("Websocket reconnected. Try reauthenticating");
          if (meetingDetails) {
            vpaasSignals.onReconnecting.emit();
            await _authenticate(meetingDetails);
            if (call) {
              connect(props);
            }
            vpaasSignals.onReconnected.emit();
          }
        } catch (error) {
          logger4.error("Reauthenticating failed. Try reconnecting");
          await _reconnect();
        }
      }));
      detachSignals.push(socketSignals.onDisconnected.add(async ({ code }) => {
        if (!isWebSocketClosedWithError(code)) {
          return;
        }
        rejoinAttempt++;
        if (rejoinAttempt < MAX_RECONNECT_ATTEMPTS2) {
          logger4.error("Websocket disconnected. Try rejoining");
          disconnect();
          await _rejoin();
        } else {
          logger4.error("Websocket disconnected. That's it.");
        }
      }));
    } catch (error) {
      if (error instanceof Error && error.name !== "AbortError") {
        disconnect();
        if (error instanceof GoneError) {
          vpaasSignals.onError.emit(VpaasError.MEETING_EXPIRED);
        } else if (error instanceof NotFoundError) {
          vpaasSignals.onError.emit(VpaasError.MEETING_NOT_FOUND);
        } else if (error instanceof MeetingFullError) {
          vpaasSignals.onError.emit(VpaasError.MEETING_FULL);
        } else {
          vpaasSignals.onError.emit(VpaasError.CONNECTION_FAILED);
        }
        throw error;
      }
    }
  };
  const connect = ({ mediaInits, abortController }) => {
    props.mediaInits = mediaInits;
    if (call) {
      call.close();
    }
    call = createCall({
      abortController,
      meeSignals: vpaasSignals,
      socket,
      socketSignals,
      ...props
    });
  };
  const disconnect = () => {
    socket.disconnect(SocketCloseEventCode.NormalClosure);
    call == null ? void 0 : call.close();
    detachSignals.forEach((detach) => detach());
    detachSignals = [];
  };
  const requestStream = async (args) => {
    const res = await send({ type: "request_stream", ...args });
    if (res.type !== "request_stream_response") {
      throw new Error(res.type ?? "Unexpected response type");
    }
    return res;
  };
  const disconnectStream = async (args) => {
    await send({ type: "disconnect_stream", ...args });
  };
  return {
    getTransceiverConfigs() {
      return (call == null ? void 0 : call.pc.getTransceiverConfigs()) ?? [];
    },
    addConfig(initOrConfig) {
      return call == null ? void 0 : call.pc.addConfig(call == null ? void 0 : call.pc.peer, initOrConfig);
    },
    setStream(stream) {
      call == null ? void 0 : call.setStream(stream);
    },
    present(presentationStream) {
      call == null ? void 0 : call.present(presentationStream);
    },
    stopPresenting() {
      call == null ? void 0 : call.stopPresenting();
    },
    joinMeeting,
    connect,
    disconnect,
    requestStream,
    disconnectStream
  };
};
export {
  AbortReason,
  BACKOFF_BASE_SETTINGS2 as BACKOFF_BASE_SETTINGS,
  BadRequestError,
  GoneError,
  MAX_RECONNECT_ATTEMPTS2 as MAX_RECONNECT_ATTEMPTS,
  MeetingFullError,
  NotFoundError,
  ResourceUnavailableError,
  VpaasError,
  WebsocketError,
  createRecvTransceivers,
  createSocketSignals2 as createSocketSignals,
  createVpaas,
  createVpaasSignals,
  getTraceparent,
  isAudioConfig,
  isInactiveConfig,
  isMainConfig,
  isMainSendConfig,
  isPresoConfig,
  isPresoInactiveConfig,
  isPresoRecvConfig,
  isPresoSendConfig,
  isPresoVideo,
  isRecvConfig,
  isResponseError,
  isSendConfig,
  isVideoConfig,
  retriable,
  setLogger4 as setLogger,
  sleep
};
//# sourceMappingURL=@pexip_vpaas-sdk.js.map
